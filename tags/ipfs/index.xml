<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ipfs on FILVIP</title>
    <link>/tags/ipfs/</link>
    <description>FILVIP (ipfs)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 22 Mar 2019 20:13:52 +0800</lastBuildDate>
    
    <atom:link href="/tags/ipfs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>IPFS Cluster 实战 -- 使用预设置添加节点</title>
      <link>/posts/ipfs-clustershi-tian-jia-jie-dian/</link>
      <pubDate>Fri, 22 Mar 2019 20:13:52 +0800</pubDate>
      
      <guid>/posts/ipfs-clustershi-tian-jia-jie-dian/</guid>
      <description>&lt;h2 id=&#34;准备工作&#34;&gt;准备工作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;安装并运行 IPFS&lt;/li&gt;
&lt;li&gt;根据操作系统下载预编译好的 ipfs ipfs-cluster-service 和 ipfs-cluster-ctl，本文以 ubuntu 为例&lt;/li&gt;
&lt;li&gt;将可执行文件 ipfs-cluster-service 和 ipfs-cluster-ctl 拷贝到 /usr/local/bin 目录下，使其可以当做全局工具使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上是前置准备工作，每一个节点都需要做好这些前置步骤。接下来要进行集群配置。&lt;/p&gt;
&lt;h2 id=&#34;step-0--设置-cluster_secret-环境变量&#34;&gt;Step 0.  设置 CLUSTER_SECRET 环境变量&lt;/h2&gt;
&lt;p&gt;在机器 node0 上运行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export CLUSTER_SECRET=$(od  -vN 32 -An -tx1 /dev/urandom | tr -d &#39; \n&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假设得到的 CLUSTER_SECRET 变量值为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;9a420ec947512b8836d8eb46e1c56fdb746ab8a78015b9821e6b46b38344038f&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此后运行 &lt;code&gt;ipfs-cluster-service init&lt;/code&gt;，那么生成的 ~/.ipfs-cluster/service.json 文件中 secret 值即为上述变量值。&lt;/p&gt;
&lt;p&gt;接着在其余机器上运行如下命令，使 secret 保持一致：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export CLUSTER_SECRET=9a420ec947512b8836d8eb46e1c56fdb746ab8a78015b9821e6b46b38344038f

ipfs-cluster-service init
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;step-1-配置-servicejson-文件中-init_peerset-字段&#34;&gt;Step 1. 配置 service.json 文件中 init_peerset 字段&lt;/h2&gt;
&lt;p&gt;该字段填写的内容是，每个节点的 service.json 文件中的 cluster.id 字段。示例如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;init_peerset&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;:&lt;/span&gt; [
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;QmeoUFMoWu1erV4XZv3VptTgfU1dHBAzA8zsZZpB9WmVkX&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;QmbsNsnW5vFg9YXmDAfubz8PuAg4SNCKx8q6DUdbKTzEkd&amp;#34;&lt;/span&gt;
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;需要注意是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;init_peerset 需要包含所有节点的 id。所有节点的该字段值都相同。&lt;/li&gt;
&lt;li&gt;这个 id 指的不是 ipfs id，而是 ipfs-cluster 的id，即 service.json 文件中的 cluster.id。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;step-2-配置-peerstore-文件&#34;&gt;Step 2. 配置 peerstore 文件&lt;/h2&gt;
&lt;p&gt;peerstore 所处的位置是 ~/.ipfs-cluster/peerstore 。该文件必须包含至少一个其他节点的 multiaddress。示例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/ip4/192.168.0.14/tcp/9096/ipfs/QmeoUFMoWu1erV4XZv3VptTgfU1dHBAzA8zsZZpB9WmVkX
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;step-3-启动&#34;&gt;Step 3. 启动&lt;/h2&gt;
&lt;p&gt;在每个节点中运行 &lt;code&gt;ipfs-cluster-service daemon&amp;amp;&lt;/code&gt; ，注意如果原来 ~/.ipfs-cluster/raft 文件夹存在的话，先把该文件夹删除。&lt;/p&gt;
&lt;p&gt;启动过后，稍等片刻，就可以查看集群节点信息：&lt;code&gt;ipfs-cluster-ctl peers ls&lt;/code&gt;。结果示例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;QmbsNsnW5vFg9YXmDAfubz8PuAg4SNCKx8q6DUdbKTzEkd | epn-ipfs-011 | Sees 1 other peers
  &amp;gt; Addresses:
    - /ip4/127.0.0.1/tcp/9096/ipfs/QmbsNsnW5vFg9YXmDAfubz8PuAg4SNCKx8q6DUdbKTzEkd
    - /ip4/192.168.0.11/tcp/9096/ipfs/QmbsNsnW5vFg9YXmDAfubz8PuAg4SNCKx8q6DUdbKTzEkd
  &amp;gt; IPFS: QmPYLxvP9psgMJq2Dwj1GtDaKYbZrdEzPaLgu7jvHHvCNw
    - /ip4/127.0.0.1/tcp/4001/ipfs/QmPYLxvP9psgMJq2Dwj1GtDaKYbZrdEzPaLgu7jvHHvCNw
    - /ip4/157.255.51.177/tcp/4001/ipfs/QmPYLxvP9psgMJq2Dwj1GtDaKYbZrdEzPaLgu7jvHHvCNw
    - /ip4/192.168.0.11/tcp/4001/ipfs/QmPYLxvP9psgMJq2Dwj1GtDaKYbZrdEzPaLgu7jvHHvCNw
    - /ip6/::1/tcp/4001/ipfs/QmPYLxvP9psgMJq2Dwj1GtDaKYbZrdEzPaLgu7jvHHvCNw
QmeoUFMoWu1erV4XZv3VptTgfU1dHBAzA8zsZZpB9WmVkX | epn-ipfs-012 | Sees 1 other peers
  &amp;gt; Addresses:
    - /ip4/127.0.0.1/tcp/9096/ipfs/QmeoUFMoWu1erV4XZv3VptTgfU1dHBAzA8zsZZpB9WmVkX
    - /ip4/192.168.0.14/tcp/9096/ipfs/QmeoUFMoWu1erV4XZv3VptTgfU1dHBAzA8zsZZpB9WmVkX
  &amp;gt; IPFS: Qme6bkxMVu4cHcncuSy7kB4AvWGZpmNNaDeZXKqf2QGfj5
    - /ip4/127.0.0.1/tcp/4001/ipfs/Qme6bkxMVu4cHcncuSy7kB4AvWGZpmNNaDeZXKqf2QGfj5
    - /ip4/157.255.51.51/tcp/4001/ipfs/Qme6bkxMVu4cHcncuSy7kB4AvWGZpmNNaDeZXKqf2QGfj5
    - /ip4/192.168.0.14/tcp/4001/ipfs/Qme6bkxMVu4cHcncuSy7kB4AvWGZpmNNaDeZXKqf2QGfj5
    - /ip6/::1/tcp/4001/ipfs/Qme6bkxMVu4cHcncuSy7kB4AvWGZpmNNaDeZXKqf2QGfj5
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://cluster.ipfs.io/documentation/configuration/#the-peerstore-file&#34;&gt;https://cluster.ipfs.io/documentation/configuration/#the-peerstore-file&lt;/a&gt;
&lt;a href=&#34;https://cluster.ipfs.io/documentation/starting/#starting-multiple-peers-with-a-fixed-peerset&#34;&gt;https://cluster.ipfs.io/documentation/starting/#starting-multiple-peers-with-a-fixed-peerset&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IPFS Cluster 实战 -- 多集群通信</title>
      <link>/posts/ipfs-cluster-shi-zhan-duo-ji-qun-tong-xin/</link>
      <pubDate>Thu, 21 Mar 2019 20:02:45 +0800</pubDate>
      
      <guid>/posts/ipfs-cluster-shi-zhan-duo-ji-qun-tong-xin/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;/images/cluster/cluster-of-clusters.png&#34; alt=&#34;cluster-of-clusters&#34;&gt;&lt;/p&gt;
&lt;p&gt;ipfs-cluster-service 提供了对 ipfs 节点的代理功能，使得整个 cluster 可以对外当做一个 ipfs 节点一样来使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代理端口默认开在 9095&lt;/li&gt;
&lt;li&gt;对一部分命令进行了封装，例如：&lt;code&gt;ipfs --api /ip4/127.0.0.1/tcp/9095 add myfile.txt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对于没有进行封装的命令，将会穿透访问到 ipfs 节点本身，例如访问 &lt;code&gt;ipfs --api /ip4/127.0.0.1/tcp/9095 repo gc&lt;/code&gt; 和访问 &lt;code&gt;ipfs repo gc&lt;/code&gt; 效果一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常用命令&#34;&gt;常用命令&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;(1) ipfs --api /ip4/127.0.0.1/tcp/9095 add myfile.txt
    该命令将本地 myfile.txt 的内容添加到本地 IPFS 节点中，并且将文件对应的哈希值添加到集群中。

(2) ipfs --api /ip4/127.0.0.1/tcp/9095 pin add &amp;lt;cid&amp;gt;
    根据 cid 获取网络中对应的内容，写入本地 IPFS 节点，并且将该哈希值添加到集群中。
    
(3) ipfs --api /ip4/127.0.0.1/tcp/9095 pin rm &amp;lt;cid&amp;gt;
    将该 cid 记录从本集群中移除。

(4) ipfs --api /ip4/127.0.0.1/tcp/9095 pin ls 
    显示本集群中所有的 pin 记录。

(5) ipfs repo gc 
    该命令会触发 gc 操作，回收所有 unpin 的内容在 IPFS 节点中所占用的存储空间。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://cluster.ipfs.io/documentation/composite-clusters/&#34;&gt;https://cluster.ipfs.io/documentation/composite-clusters/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IPFS Cluster 实战 -- supervisor 托管</title>
      <link>/posts/ipfs-cluster-shi-zhan-supervisor-guan-li-ipfs-cluster-service/</link>
      <pubDate>Thu, 21 Mar 2019 17:05:28 +0800</pubDate>
      
      <guid>/posts/ipfs-cluster-shi-zhan-supervisor-guan-li-ipfs-cluster-service/</guid>
      <description>&lt;p&gt;配置模版：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[program:ipfs-cluster-service]
command=/bin/bash -c &amp;quot;/usr/local/bin/ipfs-cluster-service daemon&amp;quot;
environment=HOME=&amp;quot;/home/deploy&amp;quot;,USER=&amp;quot;deploy&amp;quot;
user=deploy
process_name=%(program_name)s ; process_name expr (default %(program_name)s)
numprocs=1                    ; number of processes copies to start (def 1)
startsecs=1                   ; number of secs prog must stay running (def. 1)
startretries=3                ; max # of serial start failures (default 3)
user=deploy                     ; setuid to this UNIX account to run the program
redirect_stderr=true          ; redirect proc stderr to stdout (default false)
stdout_logfile=/home/deploy/logs/ipfs-cluster-service.stdout.log
stdout_logfile_maxbytes=50MB  ; max # logfile bytes b4 rotation (default 50MB)
stdout_logfile_backups=10     ; # of stdout logfile backups (default 10)
stdout_capture_maxbytes=1MB   ; number of bytes in &#39;capturemode&#39; (default 0)
stdout_events_enabled=false   ; emit events on stdout writes (default false)
stderr_logfile=/home/deploy/logs/ipfs-cluster-service.stderr.log
stderr_logfile_maxbytes=10MB  ; max # logfile bytes b4 rotation (default 50MB)
stderr_logfile_backups=10     ; # of stderr logfile backups (default 10)
stderr_capture_maxbytes=1MB   ; number of bytes in &#39;capturemode&#39; (default 0)
stderr_events_enabled=false   ; emit events on stderr writes (default false)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个&lt;a href=&#34;https://github.com/ipfs/go-ipfs/issues/861&#34;&gt;提问&lt;/a&gt; 解释了为什么需要这样配置 command 和 environment。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IPFS Cluster 实战 -- 概览</title>
      <link>/posts/ipfs-cluster-shi-zhan-gai-lan/</link>
      <pubDate>Wed, 20 Mar 2019 20:58:44 +0800</pubDate>
      
      <guid>/posts/ipfs-cluster-shi-zhan-gai-lan/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;IPFS Cluster 是 IPFS 集群的编排工具。&lt;/li&gt;
&lt;li&gt;一个 IPFS 节点对应一个 IPFS Cluster 的 peer。&lt;/li&gt;
&lt;li&gt;IPFS Cluster peers 采用 libp2p 进行通信，与 IPFS 类似。&lt;/li&gt;
&lt;li&gt;同一个 IPFS Cluster 的节点需要确保 Secret 一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/cluster/cluster-overview.png&#34; alt=&#34;overview&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;已有特性&#34;&gt;已有特性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;多节点之间内容的复制，pin，add 操作。&lt;/li&gt;
&lt;li&gt;从多节点中获取内容&lt;/li&gt;
&lt;li&gt;采用基于 Raft 的共识&lt;/li&gt;
&lt;li&gt;控制副本数的上限和下限&lt;/li&gt;
&lt;li&gt;某个 pin 操作失败后，会自动重试&lt;/li&gt;
&lt;li&gt;节点存储负载均衡&lt;/li&gt;
&lt;li&gt;集群数据的导入和导出 （Pin-set exports and imports）&lt;/li&gt;
&lt;li&gt;集群节点动态添加和移除&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://cluster.ipfs.io/documentation/overview/&#34;&gt;https://cluster.ipfs.io/documentation/overview/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IPFS 源码阅读 -- add 命令详解</title>
      <link>/posts/add-ming-ling-xiang-jie/</link>
      <pubDate>Sun, 10 Mar 2019 20:46:33 +0800</pubDate>
      
      <guid>/posts/add-ming-ling-xiang-jie/</guid>
      <description>&lt;p&gt;ipfs add 命令的入口命令是 core/commands/add.go 中的 AddCmd ，其中 PreRun 负责参数解析，Run 是真正的 add 操作的执行体，PostRun 是 add 操作的结果返回输出。&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;add 命令属于 CoreAPI ，而 CoreAPI 的定义（core/coreapi/coreapi.go）如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CoreAPI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
   &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;core&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;IpfsNode&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;dag&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;ipld&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;DAGService&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到整个 CoreAPI 主要包含 IPFSNode 对象和 DAGService，它们分别表示 IPFS  节点状态以及 IPFS Merkle DAG 状态维护的服务。&lt;/p&gt;
&lt;p&gt;因为所有核心命令其实是 CoreAPI 一个具体的实现，比如 add 命令就是 core/coreapi/unixfs.go 中的 UnixfsAPI 来负责的。&lt;/p&gt;
&lt;h2 id=&#34;unixfsapi-详解&#34;&gt;UnixfsAPI 详解&lt;/h2&gt;
&lt;p&gt;UnixfsAPI 接口定义可以查看 core/coreapi/interface/unixfs.go，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Add 方法：将一个 I/O reader 对象转化为 merkledag 节点，并且保存到 blockstore中，并返回 merkle 节点的 key。&lt;/li&gt;
&lt;li&gt;Get 方法： 返回指向一个特定的 path 的只读的 fd。&lt;/li&gt;
&lt;li&gt;Ls 方法： 返回一个目录下的所有 links。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;add-方法详解&#34;&gt;Add 方法详解&lt;/h2&gt;
&lt;p&gt;当启动 daemon 的时候，本地执行 ipfs add 其实是通过 http 代理，将请求发送到 daemon 服务，此时真正执行的是 daemon 命令中启动的 IFPS Node, 当然我们也可以在服务没有启动的时候执行 ipfs add , 此时相当于使用的是 offlineExchange。&lt;/p&gt;
&lt;p&gt;实际执行 Add 方法首先会声明一个 Adder 对象，定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Adder holds the switches passed to the `add` command.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Adder&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
   &lt;span style=&#34;color:#a6e22e&#34;&gt;ctx&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;context&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Context&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;pinning&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;pin&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pinner&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;blockstore&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bstore&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GCBlockstore&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;dagService&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ipld&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;DAGService&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;bufferedDS&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ipld&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;BufferedDAG&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Out&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt;{}
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Progress&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Hidden&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Pin&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Trickle&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;RawLeaves&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Silent&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Wrap&lt;/span&gt;       &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt;       &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;NoCopy&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Chunker&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;       &lt;span style=&#34;color:#a6e22e&#34;&gt;ipld&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;mroot&lt;/span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mfs&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Root&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;unlocker&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;bstore&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Unlocker&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;tempRoot&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;cid&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Cid&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;CidBuilder&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cid&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Builder&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;liveNodes&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后再调用 adder的 AddAllAndPin 方法。&lt;/p&gt;
&lt;h2 id=&#34;数据的存储&#34;&gt;数据的存储&lt;/h2&gt;
&lt;h3 id=&#34;创建-merkle-dag&#34;&gt;创建 merkle DAG&lt;/h3&gt;
&lt;p&gt;coreunix/add.go add首先构造chunker（数据流切分的splitter），然后根据数据流自底向上构造merkle DAG（代码位于balanced/builder.go Layout方法），详细如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/add-command.png&#34; alt=&#34;add-command.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先创建根节点&lt;/li&gt;
&lt;li&gt;如果有数据剩余则继续添加节点，同时把根节点挂入左子树&lt;/li&gt;
&lt;li&gt;填充未满的节点&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;//      &lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;Layout&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt; creates a root and hands it off to be filled:
//
//             +-------------+
//             |   Root &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;    |
//             +-------------+
//                    |
//       &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt; fillNodeRec fills in the &lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
//       &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt; chunks on the root.      &lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
//                    |
//             +------+------+
//             |             |
//        + - - - - +   + - - - - +
//        | Chunk &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; |   | Chunk &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; |
//        + - - - - +   + - - - - +
//
//                           ↓
//      When the root is full but there&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;s more data...
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;//                           ↓
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;//
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;//             +-------------+
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;//             |   Root 1    |
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;//             +-------------+
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;//                    |
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;//             +------+------+
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;//             |             |
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;//        +=========+   +=========+   + - - - - +
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;//        | Chunk 1 |   | Chunk 2 |   | Chunk 3 |
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;//        +=========+   +=========+   + - - - - +
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;//
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;//                           ↓
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;//      ...Layout&amp;#39;&lt;/span&gt;s job is to create a new root.
//                           ↓
//
//                            +-------------+
//                            |   Root &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;    |
//                            +-------------+
//                                  |
//                    +-------------+ - - - - - - - - +
//                    |                               |
//             +-------------+            &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt; fillNodeRec creates the &lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
//             |   Node &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;    |            &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt; branch that connects    &lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
//             +-------------+            &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Root 2&amp;#34;&lt;/span&gt; to &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Chunk 3.&amp;#34;&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
//                    |                               |
//             +------+------+             + - - - - -+
//             |             |             |
//        +&lt;span style=&#34;color:#f92672&#34;&gt;=========&lt;/span&gt;+   +&lt;span style=&#34;color:#f92672&#34;&gt;=========&lt;/span&gt;+   + - - - - +
//        | Chunk &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; |   | Chunk &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; |   | Chunk &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; |
//        +&lt;span style=&#34;color:#f92672&#34;&gt;=========&lt;/span&gt;+   +&lt;span style=&#34;color:#f92672&#34;&gt;=========&lt;/span&gt;+   + - - - - +
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;数据持久化&#34;&gt;数据持久化&lt;/h3&gt;
&lt;p&gt;coreunix/add.go Finalized() 调用file.go Flush方法进行数据持久化到磁盘，其中经过一些列的转化例如：shard文件到对应的目录，cid到key的转化等，最终调用flatfs.go Put方法进行落盘（首先把数据生成到临时文件，之后进行mv操作）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/add-command-02.png&#34; alt=&#34;add-command-02.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/add-command-03.png&#34; alt=&#34;add-command-03.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;flatfs 文件系统来自于配置文件的datastore-&amp;gt;Spec-&amp;gt;mounts。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IPFS 源码阅读 -- daemon 启动流程</title>
      <link>/posts/yuan-ma-yue-du-zhi-daemon-qi-dong-liu-cheng/</link>
      <pubDate>Thu, 07 Mar 2019 22:22:29 +0800</pubDate>
      
      <guid>/posts/yuan-ma-yue-du-zhi-daemon-qi-dong-liu-cheng/</guid>
      <description>&lt;h2 id=&#34;daemon-的定义&#34;&gt;daemon 的定义&lt;/h2&gt;
&lt;p&gt;ipfs daemon 命令的定义在 cmd/ipfs/daemon.go 中的 daemonCmd 变量，其中 Run 方法是 daemonFunc，daemonFunc 主要包含如下几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fsrepo.Open(): 初始化数据持久层，包括 blocks 和 DAG&lt;/li&gt;
&lt;li&gt;core.NewNode(ncfg): 节点初始化&lt;/li&gt;
&lt;li&gt;serveHTTPApi(): API HTTP 服务监听&lt;/li&gt;
&lt;li&gt;mountFuse(): mount 目录 with FUSE&lt;/li&gt;
&lt;li&gt;maybeRunGC(): 启动 Repo GC 任务监听&lt;/li&gt;
&lt;li&gt;serveHTTPGateway(): HTTP Gateway 代理服务坚听&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;fsrepoopen-详解&#34;&gt;fsrepo.Open 详解&lt;/h2&gt;
&lt;p&gt;参考 &lt;a href=&#34;http://localhost:1313/posts/ipfs-ming-ling-zhi-xing-liu-cheng/&#34;&gt;《IPFS 源码阅读 &amp;ndash; 命令执行流程》&lt;/a&gt; 文章中的 FSRepo 初始化逻辑。&lt;/p&gt;
&lt;h2 id=&#34;corenewnode-详解&#34;&gt;core.NewNode 详解&lt;/h2&gt;
&lt;p&gt;在 daemonCmd 中 node BuildCfg 被覆盖了，其值为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Start assembling node config
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ncfg&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;core&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;BuildCfg&lt;/span&gt;{
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Repo&lt;/span&gt;:                        &lt;span style=&#34;color:#a6e22e&#34;&gt;repo&lt;/span&gt;,
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Permanent&lt;/span&gt;:                   &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;// It is temporary way to signify that node is permanent
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Online&lt;/span&gt;:                      !&lt;span style=&#34;color:#a6e22e&#34;&gt;offline&lt;/span&gt;,
   &lt;span style=&#34;color:#a6e22e&#34;&gt;DisableEncryptedConnections&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;unencrypted&lt;/span&gt;,
   &lt;span style=&#34;color:#a6e22e&#34;&gt;ExtraOpts&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;{
      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;pubsub&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;pubsub&lt;/span&gt;,
      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ipnsps&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;ipnsps&lt;/span&gt;,
      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mplex&amp;#34;&lt;/span&gt;:  &lt;span style=&#34;color:#a6e22e&#34;&gt;mplex&lt;/span&gt;,
   },
   &lt;span style=&#34;color:#75715e&#34;&gt;//TODO(Kubuxu): refactor Online vs Offline by adding Permanent vs Ephemeral
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
  
&lt;span style=&#34;color:#75715e&#34;&gt;// with default dht config
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ncfg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Routing&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;core&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;DHTOption&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;core.NewNode(ctx, ncfg) 具体过程可以参考 &lt;a href=&#34;http://localhost:1313/posts/ipfs-ming-ling-zhi-xing-liu-cheng/&#34;&gt;《IPFS 源码阅读 &amp;ndash; 命令执行流程》&lt;/a&gt; 中的 Node 初始化设置，其中 cfg.Online  = true, 所以会分别执行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n.startOnlineServices(): 通过 bitswap 构建 Exchange&lt;/li&gt;
&lt;li&gt;n.startLateOnlineServices(): 通过 routing 创建 Reprovider&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;servehttpapi-详解&#34;&gt;serveHTTPApi 详解&lt;/h2&gt;
&lt;p&gt;API  HTTP 服务监听，根据配置文件中的 Addresses.API 以及运行命令参数 &amp;ndash;api 决定其监听地址。&lt;/p&gt;
&lt;h2 id=&#34;mountfuse-详解&#34;&gt;mountFuse 详解&lt;/h2&gt;
&lt;p&gt;当启动添加参数  &amp;ndash;mount 的时候，会使用到 mount Fuse 的功能，最终调用的方式是 fuse/node/mount_unix.go 中的 doMount 方法，而该方法中分别执行 fuse/readonly/mount_unix.go 和 fuse/ipns/mount_unix.go 中的 Mount 方法。&lt;/p&gt;
&lt;h2 id=&#34;mayberungc-详解&#34;&gt;maybeRunGC 详解&lt;/h2&gt;
&lt;p&gt;当启动添加 &amp;ndash;enable-gc 参数的时候，可以让 repo 启动执行 GC，对内容进行回收，本质执行的代码是 pin/gc/gc.go 的 GC 方法。具体步骤大致分为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;标记不需要删除的 cid，即所有递归和直接 pinned , bestEffortRoots（白名单，例如filesRoot）, 以及 pinner 内部使用的 blocks。&lt;/li&gt;
&lt;li&gt;扫描所有 blocks 中的所有key, 依次检测是否需要删除。&lt;/li&gt;
&lt;li&gt;如果需要删除，直接删除本地 /blocks/下的文件即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;servehttpgateway-详解&#34;&gt;serveHTTPGateway 详解&lt;/h2&gt;
&lt;p&gt;Gateway  HTTP 服务监听，根据配置文件中的 Addresses.Gateway 决定其监听地址，可以通过 gateway 服务，采用 http 方式访问 ipfs 网络中的内容。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IPFS 源码阅读 -- 命令执行流程</title>
      <link>/posts/ipfs-ming-ling-zhi-xing-liu-cheng/</link>
      <pubDate>Fri, 01 Mar 2019 20:07:52 +0800</pubDate>
      
      <guid>/posts/ipfs-ming-ling-zhi-xing-liu-cheng/</guid>
      <description>&lt;p&gt;使用 IPFS 的命令（包括 daemon）会按照一个通用的流程来执行，下面我们就来看看整个命令执行过程。&lt;/p&gt;
&lt;h2 id=&#34;ipfs-command-定义&#34;&gt;IPFS command 定义&lt;/h2&gt;
&lt;p&gt;Command 结构体是对 ipfs 命令的一个抽象，其中最核心的是  PreRun, Run, PostRun，通常执行的过程是先执行 PreRun -&amp;gt; go PostRun -&amp;gt; Run。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Command is a runnable command, with input arguments and options (flags).
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// It can also have Subcommands, to group units of work into sets.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Options&lt;/span&gt;   []&lt;span style=&#34;color:#a6e22e&#34;&gt;cmdkit&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Option&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Arguments&lt;/span&gt; []&lt;span style=&#34;color:#a6e22e&#34;&gt;cmdkit&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Argument&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;PreRun&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;req&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Request&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;env&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Environment&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;
 
   &lt;span style=&#34;color:#75715e&#34;&gt;// Run is the function that processes the request to generate a response.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;// Note that when executing the command over the HTTP API you can only read
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;// after writing when using multipart requests. The request body will not be
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;// available for reading after the HTTP connection has been written to.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Run&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;Function&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;PostRun&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;PostRunMap&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Encoders&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;EncoderMap&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Helptext&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cmdkit&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;HelpText&lt;/span&gt;
 
   &lt;span style=&#34;color:#75715e&#34;&gt;// External denotes that a command is actually an external binary.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;// fewer checks and validations will be performed on such commands.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;External&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;
 
   &lt;span style=&#34;color:#75715e&#34;&gt;// Type describes the type of the output of the Command&amp;#39;s Run Function.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;// In precise terms, the value of Type is an instance of the return type of
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;// the Run Function.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;//
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;// ie. If command Run returns &amp;amp;Block{}, then Command.Type == &amp;amp;Block{}
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Type&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt;{}
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Subcommands&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Command&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;执行流程&#34;&gt;执行流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/cmd-01.png&#34; alt=&#34;cmd-01&#34;&gt;&lt;/p&gt;
&lt;p&gt;流程说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义 buildEnv， makeExecutor 函数&lt;/li&gt;
&lt;li&gt;通过 cli.Run() 执行命令:  buildEnv() -&amp;gt; makeExecutor()&lt;/li&gt;
&lt;li&gt;执行 Run 的过程中还会涉及到到配置和节点实例化&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;oldcmdscontext-详解&#34;&gt;oldcmds.Context 详解&lt;/h2&gt;
&lt;p&gt;一个 ipfs cmd 运行时会携带一个运行时的上下文，即一个  commands/request.go 中的 Context 对象，它定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Context&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Online&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;ConfigRoot&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;ReqLog&lt;/span&gt;     &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ReqLog&lt;/span&gt;
 
   &lt;span style=&#34;color:#a6e22e&#34;&gt;config&lt;/span&gt;     &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;config&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Config&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;LoadConfig&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;config&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Config&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;)
 
   &lt;span style=&#34;color:#a6e22e&#34;&gt;api&lt;/span&gt;           &lt;span style=&#34;color:#a6e22e&#34;&gt;coreiface&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;CoreAPI&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;core&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;IpfsNode&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;ConstructNode&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;() (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;core&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;IpfsNode&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中最关键的是 LoadConfig 和 ConstructNode，具体含义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LoadConfig: 加载配置文件&lt;/li&gt;
&lt;li&gt;ConstructNode: 节点构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而在 cmd/ipfs/main.go 的 mainRet() 函数中，它的定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;buildEnv&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;ctx&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;context&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Context&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;req&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cmds&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Request&lt;/span&gt;) (&lt;span style=&#34;color:#a6e22e&#34;&gt;cmds&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Environment&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;) {
   &lt;span style=&#34;color:#75715e&#34;&gt;// 此处省略代码
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;// this sets up the function that will initialize the node
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;// this is so that we can construct the node lazily.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;oldcmds&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Context&lt;/span&gt;{
      &lt;span style=&#34;color:#a6e22e&#34;&gt;ConfigRoot&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;repoPath&lt;/span&gt;,
      &lt;span style=&#34;color:#a6e22e&#34;&gt;LoadConfig&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;loadConfig&lt;/span&gt;,
      &lt;span style=&#34;color:#a6e22e&#34;&gt;ReqLog&lt;/span&gt;:     &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;oldcmds&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ReqLog&lt;/span&gt;{},
      &lt;span style=&#34;color:#a6e22e&#34;&gt;ConstructNode&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;() (&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;core&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;IpfsNode&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;) {
         &lt;span style=&#34;color:#75715e&#34;&gt;// 此处省略代码
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fsrepo&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Open&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;repoPath&lt;/span&gt;)
         &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; { &lt;span style=&#34;color:#75715e&#34;&gt;// repo is owned by the node
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;
         }
 
         &lt;span style=&#34;color:#75715e&#34;&gt;// ok everything is good. set it on the invocation (for ownership)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;         &lt;span style=&#34;color:#75715e&#34;&gt;// and return it.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;core&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;NewNode&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;ctx&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;core&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;BuildCfg&lt;/span&gt;{
            &lt;span style=&#34;color:#a6e22e&#34;&gt;Repo&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;,
         })
         &lt;span style=&#34;color:#75715e&#34;&gt;// 此处省略代码
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      },
   }, &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;配置实例化&#34;&gt;配置实例化&lt;/h2&gt;
&lt;p&gt;go-ipfs-config/config.go 中的 Config 是整个 IPFS 的配置说明，它由上面提到的命令运行的上下文 Context 来管理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Config is used to load ipfs config files.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Config&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Identity&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;Identity&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// local node&amp;#39;s peer identity
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Datastore&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Datastore&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// local node&amp;#39;s storage
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Addresses&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Addresses&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// local node&amp;#39;s addresses
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Mounts&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Mounts&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// local node&amp;#39;s mount points
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Discovery&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Discovery&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// local node&amp;#39;s discovery mechanisms
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Routing&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Routing&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;// local node&amp;#39;s routing settings
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Ipns&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;Ipns&lt;/span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// Ipns settings
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Bootstrap&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// local nodes&amp;#39;s bootstrap peer addresses
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Gateway&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Gateway&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;// local node&amp;#39;s gateway server options
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;API&lt;/span&gt;       &lt;span style=&#34;color:#a6e22e&#34;&gt;API&lt;/span&gt;       &lt;span style=&#34;color:#75715e&#34;&gt;// local node&amp;#39;s API settings
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Swarm&lt;/span&gt;     &lt;span style=&#34;color:#a6e22e&#34;&gt;SwarmConfig&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Pubsub&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;PubsubConfig&lt;/span&gt;
 
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Reprovider&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Reprovider&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Experimental&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Experiments&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;实例化：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;调用 cmd.Context  中的 LoadConfig 函数（在 buildEnv 中有定义），实际调用的是 cmd/ipfs/main.go 中的 loadConfig() 函数，本质是一个简单的 JSON unmarshal 操作,具体过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/cmd-02.png&#34; alt=&#34;cmd-02&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;node-实例化&#34;&gt;Node 实例化&lt;/h2&gt;
&lt;p&gt;IPFS 运行时候需要实例化一个 core/core.go  IpfsNode 对象，它用来封装对 整个 IPFS 节点的管理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// IpfsNode is IPFS Core module. It represents an IPFS instance.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;IpfsNode&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
 
   &lt;span style=&#34;color:#75715e&#34;&gt;// Self
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Identity&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;peer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ID&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// the local node&amp;#39;s identity
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; 
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Repo&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;repo&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Repo&lt;/span&gt;
 
   &lt;span style=&#34;color:#75715e&#34;&gt;// Local node
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Pinning&lt;/span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;pin&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pinner&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// the pinning manager
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Mounts&lt;/span&gt;          &lt;span style=&#34;color:#a6e22e&#34;&gt;Mounts&lt;/span&gt;     &lt;span style=&#34;color:#75715e&#34;&gt;// current mount state, if any.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;PrivateKey&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;ic&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;PrivKey&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// the local node&amp;#39;s private Key
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;PNetFingerprint&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;     &lt;span style=&#34;color:#75715e&#34;&gt;// fingerprint of private network
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; 
   &lt;span style=&#34;color:#75715e&#34;&gt;// Services
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Peerstore&lt;/span&gt;       &lt;span style=&#34;color:#a6e22e&#34;&gt;pstore&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Peerstore&lt;/span&gt;     &lt;span style=&#34;color:#75715e&#34;&gt;// storage for other Peer instances
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Blockstore&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;bstore&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GCBlockstore&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// the block store (lower level)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Filestore&lt;/span&gt;       &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;filestore&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Filestore&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// the filestore blockstore
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;BaseBlocks&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;bstore&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Blockstore&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// the raw blockstore, no filestore wrapping
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;GCLocker&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;bstore&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GCLocker&lt;/span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// the locker used to protect the blockstore during gc
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Blocks&lt;/span&gt;          &lt;span style=&#34;color:#a6e22e&#34;&gt;bserv&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;BlockService&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;// the block service, get/add blocks.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;DAG&lt;/span&gt;             &lt;span style=&#34;color:#a6e22e&#34;&gt;ipld&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;DAGService&lt;/span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// the merkle dag service, get/add objects.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Resolver&lt;/span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;resolver&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Resolver&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;// the path resolution system
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Reporter&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;metrics&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Reporter&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;Discovery&lt;/span&gt;       &lt;span style=&#34;color:#a6e22e&#34;&gt;discovery&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Service&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;FilesRoot&lt;/span&gt;       &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mfs&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Root&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;RecordValidator&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;record&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Validator&lt;/span&gt;
 
   &lt;span style=&#34;color:#75715e&#34;&gt;// Online
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;PeerHost&lt;/span&gt;     &lt;span style=&#34;color:#a6e22e&#34;&gt;p2phost&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Host&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// the network host (server+client)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Bootstrapper&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;io&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Closer&lt;/span&gt;           &lt;span style=&#34;color:#75715e&#34;&gt;// the periodic bootstrapper
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Routing&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;routing&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;IpfsRouting&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// the routing system. recommend ipfs-dht
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Exchange&lt;/span&gt;     &lt;span style=&#34;color:#a6e22e&#34;&gt;exchange&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Interface&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// the block exchange + strategy (bitswap)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Namesys&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;namesys&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;NameSystem&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// the name system, resolves paths to hashes
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;Reprovider&lt;/span&gt;   &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;rp&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Reprovider&lt;/span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// the value reprovider system
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;IpnsRepub&lt;/span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ipnsrp&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Republisher&lt;/span&gt;
 
   &lt;span style=&#34;color:#a6e22e&#34;&gt;PubSub&lt;/span&gt;   &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;pubsub&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;PubSub&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;PSRouter&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;psrouter&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;PubsubValueStore&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;DHT&lt;/span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;dht&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;IpfsDHT&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;P2P&lt;/span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;p2p&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;P2P&lt;/span&gt;
 
   &lt;span style=&#34;color:#a6e22e&#34;&gt;proc&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;goprocess&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Process&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;ctx&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;context&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Context&lt;/span&gt;
 
   &lt;span style=&#34;color:#a6e22e&#34;&gt;mode&lt;/span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;mode&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;localModeSet&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;实例化：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;调用 cmd.Context  中的 ConstructNode 函数（在 buildEnv 中有定义），具体过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/cmd-03.png&#34; alt=&#34;cmd-03&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，整个过程主要分为以下三步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FSRepo 初始化&lt;/li&gt;
&lt;li&gt;BuildCfg 初始化&lt;/li&gt;
&lt;li&gt;Node 的初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;fsrepo-初始化&#34;&gt;FSRepo 初始化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;repo/fsrepo/fsrepo.go 中的 FSRepo 的定义：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// FSRepo represents an IPFS FileSystem Repo. It is safe for use by multiple
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// callers.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FSRepo&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
   &lt;span style=&#34;color:#75715e&#34;&gt;// has Close been called already
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;closed&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;
   &lt;span style=&#34;color:#75715e&#34;&gt;// path is the file-system path
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
   &lt;span style=&#34;color:#75715e&#34;&gt;// lockfile is the file system lock to prevent others from opening
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;// the same fsrepo path concurrently
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;lockfile&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;io&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Closer&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;config&lt;/span&gt;   &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;config&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Config&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;ds&lt;/span&gt;       &lt;span style=&#34;color:#a6e22e&#34;&gt;repo&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Datastore&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;keystore&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;keystore&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Keystore&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;filemgr&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;filestore&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;FileManager&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;初始化流程：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/cmd-04.png&#34; alt=&#34;cmd-04&#34;&gt;&lt;/p&gt;
&lt;p&gt;IPFS 整个数据存储都是在这步骤完成的，其中主要包含存储 blocks 块的 FlatfsDatastore 以及 KV 元信息存储的 LeveldsDatastore。&lt;/p&gt;
&lt;h3 id=&#34;node-初始化设置&#34;&gt;Node 初始化设置&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;/images/cmd-05.png&#34; alt=&#34;cmd-05&#34;&gt;&lt;/p&gt;
&lt;p&gt;到此，我们通过阅读 IPFS 源代码，基本了解了其 Command 的执行流程，也对 IPFS 的启动有了一个深入的了解。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IPFS PubSub 从入门到精通</title>
      <link>/posts/ipfs-pubsub-cong-ru-men-dao-jing-tong/</link>
      <pubDate>Thu, 28 Feb 2019 17:29:43 +0800</pubDate>
      
      <guid>/posts/ipfs-pubsub-cong-ru-men-dao-jing-tong/</guid>
      <description>&lt;p&gt;IPFS 有个叫 PubSub 的功能模块，能够实现 IPFS 网络中任意消息的订阅和发布，我们先来看个简单的例子。&lt;/p&gt;
&lt;h3 id=&#34;pubsub-示例&#34;&gt;PubSub 示例&lt;/h3&gt;
&lt;p&gt;Step 1: 开启 pubsub 功能&lt;/p&gt;
&lt;p&gt;因为 pubsub 属于实验功能，所以我们需要以 &lt;code&gt;--enable-pubsub-experiment&lt;/code&gt; 参数来运行，我们在本地启动三个IPFS节点，并相互连接：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd ~/ipfstest/node1
$ ipfs daemon --enable-pubsub-experiment
Initializing daemon...

$ cd ~/ipfstest/node2
$ ipfs daemon --enable-pubsub-experiment
Initializing daemon...

$ cd ~/ipfstest/node3
$ ipfs daemon --enable-pubsub-experiment
Initializing daemon...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;三个节点的 ID 分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;node1: QmaEhAQ3DHC9NyEFTQfd9q4V3FVp9hUt5NCbnFq6bWX4Dk&lt;/li&gt;
&lt;li&gt;node2: QmRYgkFHhMLhDXKd33n178MNuPHSr8DbBE4UPDHjyoz3BZ&lt;/li&gt;
&lt;li&gt;node3: QmXsSe9HsTGrmotAwZ3YHPotPgFFpRHwjwfGLpzCcxsEPx&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此时通过任意一个节点可以看到另外两个节点，例如 node1：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs swarm peers

/ip4/10.12.220.142/tcp/4002/ipfs/QmXsSe9HsTGrmotAwZ3YHPotPgFFpRHwjwfGLpzCcxsEPx
/ip4/10.12.220.142/tcp/4011/ipfs/QmRYgkFHhMLhDXKd33n178MNuPHSr8DbBE4UPDHjyoz3BZ
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Step 2: 订阅主题：&lt;/p&gt;
&lt;p&gt;分别让 node1 和 node2 订阅主题 &lt;code&gt;my-topic&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd ~/ipfstest/node1
ipfs pubsub sub my-topic

$ cd ~/ipfstest/node2
ipfs pubsub sub my-topic
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时，node1 和 node2 的终端会卡住，等到接受新消息:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/pubsub/01.png&#34; alt=&#34;pubsub-01&#34;&gt;&lt;/p&gt;
&lt;p&gt;Step 3: 发送和接收消息：&lt;/p&gt;
&lt;p&gt;使用 node3 向主题 &lt;code&gt;my-topic&lt;/code&gt; 发送消息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd ~/ipfstest/node3
$ ipfs pubsub pub my-topic &#39;hello world&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时，node1 和 node2  将收到 &lt;code&gt;hello world&lt;/code&gt; 消息:
&lt;img src=&#34;/images/pubsub/02.png&#34; alt=&#34;pubsub-02&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;pubsub-命令详解&#34;&gt;PubSub 命令详解&lt;/h3&gt;
&lt;p&gt;我们可以使用 &lt;code&gt;ipfs pubsub --help&lt;/code&gt; 来查看 PubSub 的所有命令和参数。&lt;/p&gt;
&lt;h3 id=&#34;ls-命令&#34;&gt;ls 命令&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ls&lt;/code&gt; 命令可以列出本节点订阅的所有主题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd ~/ipfstest/node1
$ ipfs pubsub ls
my-topic

$ cd ~/ipfstest/node2
$ ipfs pubsub ls
my-topic
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;peers-命令&#34;&gt;peers 命令&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;peers&lt;/code&gt; 命令可以列出与本节点 PubSub 相连的节点，默认列出所有节点，可以通过参数过滤定阅特定主题节点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd ~/ipfstest/node1
$ ipfs pubsub peers
QmRYgkFHhMLhDXKd33n178MNuPHSr8DbBE4UPDHjyoz3BZ
QmXsSe9HsTGrmotAwZ3YHPotPgFFpRHwjwfGLpzCcxsEPx

$ ipfs pubsub peers my-topic
QmRYgkFHhMLhDXKd33n178MNuPHSr8DbBE4UPDHjyoz3BZ

$ ipfs pubsub peers temp
(空)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;sub-命令&#34;&gt;sub 命令&lt;/h3&gt;
&lt;p&gt;可以通过 &lt;code&gt;sub&lt;/code&gt; 命令订阅一个主题，该命令支持 &lt;code&gt;--discover&lt;/code&gt; 参数，表示允许通过 IPFS 网络搜素该主题的订阅节点，并与其建立连接。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs pubsub sub my-topic
$ ipfs pubsub sub my-topic --discover
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;pub-命令&#34;&gt;pub 命令&lt;/h3&gt;
&lt;p&gt;可以通过 &lt;code&gt;pub&lt;/code&gt; 向一个主题发布消息，该节点可以将消息通知到所有连接并订阅该主题的节点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs pubsub pub my-topic &#39;some message&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;pubsub-实现原理&#34;&gt;PubSub 实现原理&lt;/h3&gt;
&lt;p&gt;这里我们主要了解 PubSub 的 sub 和 pub 命令的原理。首先我们来看看 PubSub 结构体的定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// PubSub is the implementation of the pubsub system.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PubSub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
    &lt;span style=&#34;color:#75715e&#34;&gt;// atomic counter for seqnos
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// NOTE: Must be declared at the top of the struct as we perform atomic
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// operations on this field.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// See: https://golang.org/pkg/sync/atomic/#pkg-note-BUG
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// The set of topics we are subscribed to
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;myTopics&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Subscription&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt;{}
    &lt;span style=&#34;color:#75715e&#34;&gt;// topics tracks which topics each of our peers are subscribed to
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;topics&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;peer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ID&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt;{}
    &lt;span style=&#34;color:#a6e22e&#34;&gt;peers&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;peer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ID&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;RPC&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它主要涉及三个关键字段，其它字段我已忽略，含义是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;myTopics: 表示该节点订阅详情。&lt;/li&gt;
&lt;li&gt;topics: 收到的主题节点订阅情况。&lt;/li&gt;
&lt;li&gt;peers: 所有相连的节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们来看看几个核心流程，是怎样通过该三个字段实现消息订阅和发布的：&lt;/p&gt;
&lt;p&gt;状态 1: 所有三个节点两两相连&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/pubsub/node-01.png&#34; alt=&#34;node-01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;此时三个节点的 myTopics 和 topics 都为空，peers 是其它相连的两个节点。&lt;/p&gt;
&lt;p&gt;状态 2: Node1 节点执行 &lt;code&gt;ipfs pubsub sub my-topic&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/pubsub/node-02.png&#34; alt=&#34;node-02.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Node1 的 myTopics 会添加 &lt;code&gt;my-topic&lt;/code&gt; 记录。&lt;/li&gt;
&lt;li&gt;Node1 会向相连的节点广播自己新增的订阅信息，所以 Node2 和 Node3 节点的 topics 会新增 &lt;code&gt;my-topic&lt;/code&gt; 记录。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;状态 3: Node2 节点执行 &lt;code&gt;ipfs pubsub pub my-topic &#39;some message&#39;&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/pubsub/node-03.png&#34; alt=&#34;node-03.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Node2 节点从本地的 topics[&amp;ldquo;my-topic&amp;rdquo;] 中查到到订阅的节点列表为 Node1 节点。&lt;/li&gt;
&lt;li&gt;发送消息 &amp;lsquo;some message&amp;rsquo; 给 Node1 节点。&lt;/li&gt;
&lt;li&gt;Node1 收到通知消息会匹配本地的 myTopics[&amp;ldquo;my-topic&amp;rdquo;] 记录，输出到对应的 &lt;code&gt;*Subscription&lt;/code&gt;中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;状态 4: 网络中存在隔离节点（没有直接相连，DHT Table 可以检索到）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/pubsub/node-04.png&#34; alt=&#34;node-04.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果 Node4 也想发布内容到 &lt;code&gt;my-topic&lt;/code&gt;，并且能够让 Node1 收到消息，需要使用到 &lt;code&gt;--discover&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;状态 5: 使用 &lt;code&gt;--discover&lt;/code&gt; 参数，让 Node4 与 Node1 相连&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/pubsub/node-05.png&#34; alt=&#34;node-05.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &amp;ndash;discover 参数让 Node1 重新 sub &lt;code&gt;my-topic&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Node1 会在本地 blocks 文件夹下创建一个内容为 &amp;lsquo;floodsub:my-topic&amp;rsquo; 的 Block 文件，然后 IPFS 会自动将内容 Hash 发布到距离最近(XOR)的节点。&lt;/li&gt;
&lt;li&gt;Node4 也采用 &amp;ndash;discover 参数 sub &lt;code&gt;my-topic&lt;/code&gt;，此时它会根据 &amp;lsquo;floodsub:my-topic&amp;rsquo; 的内容 Hash，利用 &lt;code&gt;ipfs dht findprovs&lt;/code&gt; 命令找到 Hash 的对应提供者。&lt;/li&gt;
&lt;li&gt;尝试与所有提供者进行连接，然后将它们的节点添加到本地的 topics[&amp;ldquo;my-topic&amp;rdquo;] 列表中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;状态 6: Node4 节点执行 &lt;code&gt;ipfs pubsub pub my-topic &#39;some message again&#39;&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/pubsub/node-06.png&#34; alt=&#34;node-06.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Node4 节点从本地的 topics[&amp;ldquo;my-topic&amp;rdquo;] 中查到到订阅的节点列表为 Node1 节点。&lt;/li&gt;
&lt;li&gt;发送消息 &amp;lsquo;some message again&amp;rsquo; 给 Node1 节点。&lt;/li&gt;
&lt;li&gt;Node1 收到通知消息会匹配本地的 myTopics[&amp;ldquo;my-topic&amp;rdquo;] 记录，输出到对应的 &lt;code&gt;*Subscription&lt;/code&gt;中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;好了，到目前为止，我们学习到了 IPFS PubSub 的基本用法，参数详解以及具体实现逻辑。&lt;/p&gt;
&lt;p&gt;如果想要在复杂网络中（一开始并不直接相连的节点）使用 PubSub 功能，需要通过 &lt;code&gt;--discover&lt;/code&gt; 参数，将节点之间按照 topic 形成互联，从而实现任意地方消息订阅和发布。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IPNS 从入门到精通</title>
      <link>/posts/ipnscong-ru-men-dao-jing-tong/</link>
      <pubDate>Wed, 20 Feb 2019 17:17:12 +0800</pubDate>
      
      <guid>/posts/ipnscong-ru-men-dao-jing-tong/</guid>
      <description>&lt;p&gt;IPNS 是构建在 IPFS 之上的一套依赖 PKI的命名空间系统(namespace sytem， KV 存储空间)，其中 Key 是公钥，值是经过私钥签名的新值，所以网络中的其它节点可以根据公钥就能进行内容验证（防伪造）。&lt;/p&gt;
&lt;h3 id=&#34;为什么需要-ipns&#34;&gt;为什么需要 IPNS&lt;/h3&gt;
&lt;p&gt;众所周知，我们可以通过 &lt;code&gt;/ipfs/QmS4ust...&lt;/code&gt; 方式来访问一个对象，但由于 IPFS Hash 与内容一一对应（如果内容发生改变，Hash 值也会随之改变），所以我们访问新内容的时候需要知道新的 Hash， 这显然不够友好，那么我们是否可以通过一个固定的 Hash 来访问不同版本的内容呢？&lt;/p&gt;
&lt;p&gt;要实现上述功能，我们可以使用 IPNS，下面我们就来看看实际的例子。&lt;/p&gt;
&lt;h3 id=&#34;ipns-示例&#34;&gt;IPNS 示例&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;添加内容&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello, this IPNS example&amp;#34;&lt;/span&gt; &amp;gt; ipns.txt

$ ipfs add ipns.txt
added QmeVuuv7disk9Ri6n3QtTUCEW462UPZe3iWYFVNWNQwYxr ipns.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;发布到 IPNS 中&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ipfs name publish /ipfs/QmeVuuv7disk9Ri6n3QtTUCEW462UPZe3iWYFVNWNQwYxr
Published to QmbhgXW9LBpTcpEUerXTuoNZNd4AeHuEkb6iKx67KwSd9p: /ipfs/QmeVuuv7disk9Ri6n3QtTUCEW462UPZe3iWYFVNWNQwYxr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;通过 IPNS 查询访问内容&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ipfs cat /ipns/QmbhgXW9LBpTcpEUerXTuoNZNd4AeHuEkb6iKx67KwSd9p
hello, this IPNS example
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;修改内容，重复上述步骤&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 在 ipns.text 文件追加内容&lt;/span&gt;
$ echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello, this IPNS example&amp;#34;&lt;/span&gt; &amp;gt;&amp;gt; ipns.txt

&lt;span style=&#34;color:#75715e&#34;&gt;# 将新文件添加到 IPFS 网络&lt;/span&gt;
$ ipfs add ipns.txt
added Qmak4GvXptsAwXLFnnSfLLhpv4PLNHPRgruueKeVTUFnXP ipns.txt

&lt;span style=&#34;color:#75715e&#34;&gt;# 向网络发布最新的值&lt;/span&gt;
$ ipfs name publish Qmak4GvXptsAwXLFnnSfLLhpv4PLNHPRgruueKeVTUFnXP
Published to QmbhgXW9LBpTcpEUerXTuoNZNd4AeHuEkb6iKx67KwSd9p: /ipfs/Qmak4GvXptsAwXLFnnSfLLhpv4PLNHPRgruueKeVTUFnXP

&lt;span style=&#34;color:#75715e&#34;&gt;#通过固定的 IPNS Key 查询最新的值&lt;/span&gt;
$ ipfs cat /ipns/QmbhgXW9LBpTcpEUerXTuoNZNd4AeHuEkb6iKx67KwSd9p
hello, this IPNS example
hello, this IPNS example
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在上面的例子中，我们使用相同的 Key 先后映射 ipns.txt 文件的两个不同版本，而且使用 /ipns/KEY 的方式来获取对应内容。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;它就像一个指针，固定的 Key 指向了一个具体的内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;ipns-高级指南&#34;&gt;IPNS 高级指南&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;本地 KPI 列表&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ipfs key list 
self
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;默认使用 节点的 ID 作为 Key，并且标记为 self。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新增KPI密钥对&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs key gen ipns-example --type=rsa --size=2048
QmVsHo1xo32utEr8rsj3sjfx78WikZZ6sWGGNJTRFZu3jV

# 再次查看可以查看到新建的 `ipns-example` 
$ ipfs key list 
self
ipns-example
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;选择特定的 Key 来发布内容&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs name publish --key=ipns-example Qmak4GvXptsAwXLFnnSfLLhpv4PLNHPRgruueKeVTUFnXP
Published to QmVsHo1xo32utEr8rsj3sjfx78WikZZ6sWGGNJTRFZu3jV: /ipfs/Qmak4GvXptsAwXLFnnSfLLhpv4PLNHPRgruueKeVTUFnXP

# 使用新 Key 查询内容
$ ipfs cat /ipns/QmVsHo1xo32utEr8rsj3sjfx78WikZZ6sWGGNJTRFZu3jV
hello, this IPNS example
hello, this IPNS example
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;查询某个 Key 的映射内容（版本）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs name resolve QmbhgXW9LBpTcpEUerXTuoNZNd4AeHuEkb6iKx67KwSd9p
/ipfs/Qmak4GvXptsAwXLFnnSfLLhpv4PLNHPRgruueKeVTUFnXP
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;我们可以通过创建多个 Key，每个 Key 映射一个目录，从而实现分组需求，可以用这个功能来实现单个节点托管多个静态网站。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;ipns-实现原理&#34;&gt;IPNS 实现原理&lt;/h3&gt;
&lt;p&gt;IPNS 本质是一个KV存储，当我们知道 Key 的时候，能够在 IPFS 网络中快速查询到对应的 Value，要实现这一步， IPFS 网络中就要存储这个 KV 映射信息，那 IPFS 是如何来实现的呢？&lt;/p&gt;
&lt;p&gt;实现原理大致如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs/ipns.jpg&#34; alt=&#34;ipns.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;具体如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过 &lt;code&gt;ipfs name publish&lt;/code&gt; 发布内容时候，IPFS 节点会先将 KV 数据存储到本地的 LevelDB 中，其中 Key 的格式类似 &lt;code&gt;ipns/Qmxxx&lt;/code&gt;，默认存储时间为 24h，不过可以通过 -t 参数来设置。&lt;/li&gt;
&lt;li&gt;在本地 DHT Table 中寻找特定数量的相邻节点，寻找的过程为首先通过 Key 与 Peer 节点 ID 进行 XOR 计算，找到对应桶中的节点。&lt;/li&gt;
&lt;li&gt;相邻节点收到发布的内容后，会做签名验证验证，然后存储到本地的 LevelDB 中，这步与 1 相同。&lt;/li&gt;
&lt;li&gt;当其它节点拿到 IPNS 的 Key 的时候，可以获取与 Key 相邻的节点，与第2步的相邻节点相似，然后向它们请求该 Key 的内容。&lt;/li&gt;
&lt;li&gt;相邻节点单收到 Key 查询请求的时候，会检查本地 LevelDB 是否包含该 Key，如果包含，返回其内容，否则返回空。&lt;/li&gt;
&lt;li&gt;根据解析到的 Key 对应的具体内容ID来进行内容交换。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;qa&#34;&gt;Q&amp;amp;A&lt;/h3&gt;
&lt;p&gt;a. 默认发布的 Key 过期问题？&lt;/p&gt;
&lt;p&gt;可以通过定期 public 或者通过 -t 参数设置较长时间周期。&lt;/p&gt;
&lt;p&gt;b. 如何保证存储的可靠性？&lt;/p&gt;
&lt;p&gt;节点会向多节邻居发布映射关系，从而在部分节点下线的时候，也能在网络中查询到结果。&lt;/p&gt;
&lt;p&gt;c. 数据一致性问题？&lt;/p&gt;
&lt;p&gt;当邻居节点已经存储当前最新发布信息，此时下线，那么新的发布信息将丢失，从而导致本地存储的信息过期，当该节点重新上线后，当有节点来向它查询的时候，将会返回旧的结果。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IPFS 内容永生的理解？</title>
      <link>/posts/ipfs-nei-rong-yong-sheng-de-li-jie/</link>
      <pubDate>Fri, 18 Jan 2019 18:18:50 +0800</pubDate>
      
      <guid>/posts/ipfs-nei-rong-yong-sheng-de-li-jie/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;IPFS &lt;a href=&#34;https://github.com/ipfs/papers/raw/master/ipfs-cap2pfs/ipfs-p2p-file-system.pdf&#34;&gt;白皮书&lt;/a&gt;中提到， IPFS 甚至是一个 &lt;code&gt;Permanent&lt;/code&gt; 的网络，那是否存储在 IPFS 网络中的内容也可以永生，永远不丢失呢？&lt;/p&gt;
&lt;p&gt;显然不是，因为内容最终都需要存储在物理磁盘上，如果全网中能够提供该文件下载的节点都下线或者磁盘损坏（冷门数据，内容提供节点较少），那在整个网络中就再也无法下载完该文件的完整内容了。&lt;/p&gt;
&lt;p&gt;今天我就遇到这样的问题，下面我会来具体讲讲整个过程，以及我对 IPFS 内容“永生”新的理解。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;我们&lt;a href=&#34;https://docs.jdcloud.com/cn/object-storage-service/edgestorage&#34;&gt;边缘存储&lt;/a&gt; 产品本周新上了一个功能，在进行任务迁移的时候可以显示进度百分比。&lt;/p&gt;
&lt;p&gt;我在&lt;a href=&#34;https://zhuanlan.zhihu.com/p/35342854&#34;&gt;IPFS 看片指南：几部IPFS网络中的电影&lt;/a&gt;中找了一个叫做&lt;strong&gt;勇往直前&lt;/strong&gt;的文件，它的  CID 是 &lt;code&gt;QmZRJevYhADpXmCGGF6eCcP1afNEYFahDW5jxje3iyyCJS&lt;/code&gt;，大小为 1582221058 个字节（约 1.48GB）。&lt;/p&gt;
&lt;p&gt;在迁移到京东对象存储的过程中，发现其进度一直停留在20%，重试多次依然如此，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs/content/01.jpg&#34; alt=&#34;ipfs/content/01.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;这到底是怎么回事呢？我决定弄个明白。&lt;/p&gt;
&lt;h2 id=&#34;定位问题&#34;&gt;定位问题&lt;/h2&gt;
&lt;h4 id=&#34;step1-确定已迁移字节数&#34;&gt;Step1: 确定已迁移字节数&lt;/h4&gt;
&lt;p&gt;因为数据库记录了已迁移的字节数，根据任务 ID 很容易拿到结果是 &lt;code&gt;322699264&lt;/code&gt; 字节。&lt;/p&gt;
&lt;h4 id=&#34;step2-确定拉取失败的-cid&#34;&gt;Step2: 确定拉取失败的 CID&lt;/h4&gt;
&lt;p&gt;众所周知 IPFS 对象是一棵树状结构，它具有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个节点下面最多包含174个节点。&lt;/li&gt;
&lt;li&gt;文件的数据都存在叶子节点上，每个叶子节点默认存储 256KB 字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以&lt;strong&gt;勇往直前&lt;/strong&gt;这个电影 IPFS 的组成是一棵三层的树，结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs/content/03.png&#34; alt=&#34;03.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中根节点的 CID 是 &lt;code&gt;QmZRJe...CJS&lt;/code&gt;；第二层除最后一个节点都存储了43.5MB内容、包含174个存储256KB内容的叶子节点。&lt;/p&gt;
&lt;p&gt;因为 IPFS 内容的读取是顺序的，所以根据已经迁移的字节数很容易计算出失败的块在第二层和第三层的索引位置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第二层节点位置： (322699264 / 45613056) + 1 = 8
第三层节点位置：(322699264 % 45613056) / 262144 + 1 = 14
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;备注： 数组下标 = 位置-1&lt;/p&gt;
&lt;p&gt;下面我们通过 IPFS 的命令找到对应的 CID。&lt;/p&gt;
&lt;p&gt;a. 首先根据文件 Root CID 查询第二层的所有节点（Links）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ipfs object get QmZRJevYhADpXmCGGF6eCcP1afNEYFahDW5jxje3iyyCJS
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;命令输出内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs/content/02.png&#34; alt=&#34;ipfs/content/02.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;所得结果中 Links[7] 的 CID 是 &lt;code&gt;QmcfWDphyxf92EUv8DrHxvPDRzejeWg192cADyjyfiq33b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;b. 继续查询第三层的所有节点（Links）:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ipfs object get QmcfWDphyxf92EUv8DrHxvPDRzejeWg192cADyjyfiq33b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;命令输出内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs/content/04.png&#34; alt=&#34;ipfs/content/04.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;所得结果中 Links[13] 的 CID 是 &lt;code&gt;QmNMjt6k7qXLtiDBHzsbBzmUJ6WJ6Aqx6VP3Uwje6Crnta&lt;/code&gt;，这个就是无法拉取到内容的起始 Block CID。 使用 &lt;code&gt;ipfs dht findprovs&lt;/code&gt; 命令确认全网确实没有能够提供内容的节点。&lt;/p&gt;
&lt;p&gt;它前一个块和后一个块的 CID 分别是 &lt;code&gt;QmfMcounLQZCXaaUESkCWxZXLnoSyXfurpqxayMJALdK9w&lt;/code&gt; 和 &lt;code&gt;QmW48B3yM7KdB3HxDGWFy3XNY1Fi9rEETZLSrPtkMStEDw&lt;/code&gt;，前一个块能够查询到内容提供者：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ipfs dht findprovs QmfMcounLQZCXaaUESkCWxZXLnoSyXfurpqxayMJALdK9w
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;命令输出内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs/content/05.png&#34; alt=&#34;05.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;后一个块也无法查询到内容提供者。为什么会出现这样的结果呢？我的猜测是这样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该内容是分享在 IPFS 网络中的大文件（电影），大家在尝试播放观看该文件的时候，并没有将电影看完（缓存完全），最大缓存的位置就是拉取失败的块的前一个块的位置。&lt;/li&gt;
&lt;li&gt;首次提供该内容的节点已下线或者内容清理，GC将原始内容清除，所以全网中就再也找不到该文件的全部内容了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内容永生的理解&#34;&gt;内容“永生”的理解&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IPFS 网络中的内容通常并不会永久能访问到。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;ipfs dht findprovs&lt;/code&gt; 命令查询到某个 CID 存在的节点，并不一定能够提供该文件的完整内容，它很有可能只是记录了该文件的元信息，真实的数据块（叶子节点）有损坏。&lt;/li&gt;
&lt;li&gt;如果想要使自己的内容在 IPFS 网络中“永生”，一定永远至少存在一个能够提供该文件完整内容的节点，就是我们的产品，&lt;a href=&#34;https://docs.jdcloud.com/cn/object-storage-service/edgestorage&#34;&gt;京东云边缘存储&lt;/a&gt;存在的价值，有能力帮助你在 IPFS 网络中永久 Pin 住某个特定的文件。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>IPFS cat 命令详解</title>
      <link>/posts/ipfs-cat-ming-ling-xiang-jie/</link>
      <pubDate>Fri, 18 Jan 2019 16:10:41 +0800</pubDate>
      
      <guid>/posts/ipfs-cat-ming-ling-xiang-jie/</guid>
      <description>&lt;h2 id=&#34;命令介绍&#34;&gt;命令介绍&lt;/h2&gt;
&lt;p&gt;我们可以使用 &lt;code&gt;ipfs cat&lt;/code&gt; 命令直接查看一个文件对象（object）的内容，也可以使用 IO 重定向 &lt;code&gt;&amp;gt;&lt;/code&gt; 来进行下载，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ipfs cat QmWBbKvLhVnkryKG6F5YdkcnoVahwD7Qi3CeJeZgM6Tq68 &amp;gt; 神秘巨星.mp4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;备注： 资源来自&lt;a href=&#34;https://zhuanlan.zhihu.com/p/35342854&#34;&gt;链接&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat&lt;/code&gt; 命令支持 -o 和 -l 参数，分别表示文件读取的偏移量（offset）以及读取文件内容的长度，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ipfs cat QmWBbKvLhVnkryKG6F5YdkcnoVahwD7Qi3CeJeZgM6Tq68 -o &lt;span style=&#34;color:#ae81ff&#34;&gt;256&lt;/span&gt; -l &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注： 表示从文件 QmWBbKvLhVnkryKG6F5YdkcnoVahwD7Qi3CeJeZgM6Tq68 的第 256 个字节开始，查看10个字节的内容，这个功能很好用，我们可以用它来实现分片下载以及断点续传等功能。&lt;/p&gt;
&lt;h2 id=&#34;ipfs-文件组织方式&#34;&gt;IPFS 文件组织方式&lt;/h2&gt;
&lt;p&gt;在具体讲解 cat 命令的实现逻辑之前，我们先来了解下 IPFS 文件对象的组织方式，其实 IPFS 对象是一棵树，每个节点下面最多包含174个 Links(字节点)。文件对象的节点主要分类两种(Data_File 和 Data_Raw), 只有最下面的叶子节点才会存储真实的数据（Data_Raw），其它节点只是数据节点的元信息，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs_cat01.png&#34; alt=&#34;object.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;注： 红色（Data_File）、绿色（Data_Raw）。&lt;/p&gt;
&lt;p&gt;我们可以 QmWBbKvLhVnkryKG6F5YdkcnoVahwD7Qi3CeJeZgM6Tq68 为例，通过 &lt;code&gt;ipfs object get&lt;/code&gt; 命令来对照查看：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ipfs object get QmWBbKvLhVnkryKG6F5YdkcnoVahwD7Qi3CeJeZgM6Tq68

&lt;span style=&#34;color:#75715e&#34;&gt;# output&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; 
   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Links&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt; 
      &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; 
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Name&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;,
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hash&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;QmbmtXF9hZ6hLEubdLFP78MSPTWxUe78sYwjpCyiEJat3m&amp;#34;&lt;/span&gt;,
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Size&amp;#34;&lt;/span&gt;:45623854
      &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;, 
       ... 省略 &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt; 行 ...
 
      &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; 
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Name&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;,
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hash&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;QmXEqLu1hXe3MfDngRdV1yWmtFQbpVz1WyDHY17r6BbsYj&amp;#34;&lt;/span&gt;,
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Size&amp;#34;&lt;/span&gt;:31327573
      &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
   &lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;,
   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Data&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\u0008\u0002\u0018...&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到 &lt;code&gt;QmWBbKvLhVnkryKG6F5YdkcnoVahwD7Qi3CeJeZgM6Tq68&lt;/code&gt; 总共包含了 34 个 Link ，其中前 33 个 Link 的数据大小都为 45623854 ，最后一个大小为 31327573。然后我们再递归调用 &lt;code&gt;ipfs object get&lt;/code&gt; 分别获取所有 Link 的 内容，例如第一个 Link：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ipfs object get QmbmtXF9hZ6hLEubdLFP78MSPTWxUe78sYwjpCyiEJat3m

&lt;span style=&#34;color:#75715e&#34;&gt;# output&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; 
   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Links&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt; 
      &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; 
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Name&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;,
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hash&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;QmUgjKGQqNA4sJWbao2nBiANs46RjLAPaQrGLPHpR6Mh59&amp;#34;&lt;/span&gt;,
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Size&amp;#34;&lt;/span&gt;:262158
      &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;,
      ... 省略 &lt;span style=&#34;color:#ae81ff&#34;&gt;172&lt;/span&gt; 个...
      &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; 
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Name&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;,
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hash&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;QmSDaeEJ9ZsEGaFNx4ZMTAVcv8ncgMURKTjBeJ3gfhqkX9&amp;#34;&lt;/span&gt;,
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Size&amp;#34;&lt;/span&gt;:262158
      &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
   &lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;,
   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Data&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\u0008\u0002\u0018...&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到 &lt;code&gt;QmbmtXF9hZ6hLEubdLFP78MSPTWxUe78sYwjpCyiEJat3m&lt;/code&gt;  下面包含了 174 个文件，每个文件大小为 262158 字节，因为这些都是叶子节点，存储的都是真实的数据，而默认IPFS数据分片大小为 256KB，还添加了12个字节作为数据校准。再随意查看一个 Link ，可以看到它的实际内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ipfs object get QmUgjKGQqNA4sJWbao2nBiANs46RjLAPaQrGLPHpR6Mh59
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;/images/ipfs_cat02.png&#34; alt=&#34;store.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;到这一步，我们对IPFS文件对象的组织方式有了大概了解，那么接下来看看 cat 命令具体的实现逻辑。&lt;/p&gt;
&lt;h2 id=&#34;cat-命令实现逻辑&#34;&gt;Cat 命令实现逻辑&lt;/h2&gt;
&lt;p&gt;cat 命令的实现逻辑大致分为三步：&lt;/p&gt;
&lt;h3 id=&#34;step-1-参数解析&#34;&gt;Step 1: 参数解析&lt;/h3&gt;
&lt;p&gt;获得有效的 IPFS 或者 IPNS 对象的访问路径，例如上面的 &lt;code&gt;QmWBbKvLhVnkryKG6F5YdkcnoVahwD7Qi3CeJeZgM6Tq68&lt;/code&gt;
获得命令的运行参数，主要是 -o 和 -l&lt;/p&gt;
&lt;h3 id=&#34;step-2-递归下载-block-内容&#34;&gt;Step 2: 递归下载 Block 内容&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先获取 root cid 的内容，任何一个 cid 的内容获取过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据 cid 还原为 Block 文件 path,  先在 $IPFS_PATH/blocks/ 目录中查看文件是否存在，如果存在读取文件内容并解析。&lt;/li&gt;
&lt;li&gt;如果没有找到，尝试使用 cid 的 v1 版本，重复 1 的过程，如果没有找到，再通过 BlockService 在 bitswap p2p 网络中寻找，如果找到，进行 3），没有找到进行4）。&lt;/li&gt;
&lt;li&gt;解析内容，转化为 一个 ipld.Node ，并存储到本地的 blocks  内容中，并更新本地 BlockStorage 缓存。&lt;/li&gt;
&lt;li&gt;退出任务，提示失败。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当获取 root cid 内容的时候， IPFS 会将它封装了一个 file 对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;file 对象的读取是一个递归调用过程，直到内容读取完成或者对应长度。&lt;/li&gt;
&lt;li&gt;file 中定义了一个 4096 的缓冲区，将 Block 中的内容顺序 flush 给客户端。&lt;/li&gt;
&lt;li&gt;file 中的 Read 函数中定义了一个 precalcNextBuf 的函数，为了加快速度，该函数起了10个并发，可以同时从本地或者网络中准备好获取这10个Link 的内容到内存中（即使传入 -o、-l 参数），所以单个文件下载大约会消耗256KB * 10 = 2.5MB 内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据输入参数 -o 和 -l 设置文件读取的游标位置，主要调用 file.Seek() 函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上过程，我整理一个流程图，大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs_cat03.png&#34; alt=&#34;catflow.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IPFS 文件可以使用 -o -l 实现 range 下载。&lt;/li&gt;
&lt;li&gt;IPFS 对于单个文件是顺序下载的，在下载过程中会提前准备好10个 Blocks 的内容，所以单个文件下载最多消耗256KB*10=2.5MB 内存。&lt;/li&gt;
&lt;li&gt;下载消耗的总内存 = 总下载任务数 * 2.5MB。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>IPFS 中的 multihash</title>
      <link>/posts/ipfs-zhong-de-multihash/</link>
      <pubDate>Tue, 23 Oct 2018 19:28:20 +0800</pubDate>
      
      <guid>/posts/ipfs-zhong-de-multihash/</guid>
      <description>&lt;p&gt;在 &lt;a href=&#34;/posts/ipfs-sheng-tai-gai-lan&#34;&gt;IPFS 生态概览&lt;/a&gt; 一文中我们已经提到了 multihash，那我们就来看看在 IPFS 中是如何使用它的？&lt;/p&gt;
&lt;h2 id=&#34;为什么要用-multihash&#34;&gt;为什么要用 multihash&lt;/h2&gt;
&lt;p&gt;IPFS 默认使用的 HASH 算法是 sha2-256, 虽然现在 sha2-256 还算安全，但这并不意味它不会被攻破，随着算力的发展，说不定哪天就被破解了，所以 IPFS 需要一种可升级具有自描述的 HASH 格式，这就是 multihash。&lt;/p&gt;
&lt;h2 id=&#34;multihash-格式&#34;&gt;multihash 格式&lt;/h2&gt;
&lt;p&gt;multihash 的格式很简单，具体文档参见 &lt;a href=&#34;https://github.com/multiformats/multihash&#34;&gt;multiformats/multihash&lt;/a&gt;。它其实就是一个字符串，由三部分组成：HASH算法编码、HASH值的长度（字节数）、HASH 值 组成，形如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;varint hash function code&amp;gt;&amp;lt;varint digest size in bytes&amp;gt;&amp;lt;hash function output&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如：函数为 sha2-256，值为 32 位的 6cb42b2e29c28aeb143c3b9a0d9787f38ce2e5efea68ab01df6e121e4146ed8d 的 multihash 格式为：12206cb42b2e29c28aeb143c3b9a0d9787f38ce2e5efea68ab01df6e121e4146ed8d。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这里使用的是 sha2-256，其 HASH 编码为 0x12 ，multihash 中所有 HASH 算法编码如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// constants
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; (
   &lt;span style=&#34;color:#a6e22e&#34;&gt;ID&lt;/span&gt;         = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;SHA1&lt;/span&gt;       = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x11&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;SHA2_256&lt;/span&gt;   = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x12&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;SHA2_512&lt;/span&gt;   = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x13&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;SHA3_224&lt;/span&gt;   = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x17&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;SHA3_256&lt;/span&gt;   = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x16&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;SHA3_384&lt;/span&gt;   = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x15&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;SHA3_512&lt;/span&gt;   = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x14&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;SHA3&lt;/span&gt;       = &lt;span style=&#34;color:#a6e22e&#34;&gt;SHA3_512&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;KECCAK_224&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1A&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;KECCAK_256&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1B&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;KECCAK_384&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1C&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;KECCAK_512&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1D&lt;/span&gt;
 
   &lt;span style=&#34;color:#a6e22e&#34;&gt;SHAKE_128&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x18&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;SHAKE_256&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x19&lt;/span&gt;
 
   &lt;span style=&#34;color:#a6e22e&#34;&gt;BLAKE2B_MIN&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0xb201&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;BLAKE2B_MAX&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0xb240&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;BLAKE2S_MIN&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0xb241&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;BLAKE2S_MAX&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0xb260&lt;/span&gt;
 
   &lt;span style=&#34;color:#a6e22e&#34;&gt;DBL_SHA2_256&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x56&lt;/span&gt;
 
   &lt;span style=&#34;color:#a6e22e&#34;&gt;MURMUR3&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x22&lt;/span&gt;
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;6cb42b2e29c28aeb143c3b9a0d9787f38ce2e5efea68ab01df6e121e4146ed8d 看上去是 64 位，那是因为用了十六进制的表示方式，每个字符表示4个bit，加在一起就是 256 bit，也就是 32 字节，转化为 16 进制就是 &lt;code&gt;0x20&lt;/code&gt;，故第二位就是 &lt;code&gt;20&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;multihash-基本使用&#34;&gt;multihash 基本使用&lt;/h2&gt;
&lt;p&gt;multihash 有多种实现版本，这里我们使用 go-multihash 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;go-multihash 的安装&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;go get github.com/multiformats/go-multihash/multihash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;基本使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 multihash -h 查看其所有参数选项，可以发现它默认使用的 HASH 算法是 sha2-256，编码格式为 base58。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;usage: multihash &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;options&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;FILE&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
Print or check multihash checksums.
With no FILE, or when FILE is -, read standard input.
 
Options:
  -a string
        one of: blake2b-128, blake2b-224, blake2b-256, blake2b-384, blake2b-512, blake2s-256, dbl-sha2-256, id, keccak-224, keccak-256, keccak-384, keccak-512, murmur3, sha1, sha2-256, sha2-512, sha3, sha3-224, sha3-256, sha3-384, sha3-512, shake-128, shake-256 &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;shorthand&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;default &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sha2-256&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
  -algorithm string
        one of: blake2b-128, blake2b-224, blake2b-256, blake2b-384, blake2b-512, blake2s-256, dbl-sha2-256, id, keccak-224, keccak-256, keccak-384, keccak-512, murmur3, sha1, sha2-256, sha2-512, sha3, sha3-224, sha3-256, sha3-384, sha3-512, shake-128, shake-256 &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;default &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sha2-256&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
  -c string
        check checksum matches &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;shorthand&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
  -check string
        check checksum matches
  -e string
        one of: raw, hex, base58, base64 &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;shorthand&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;default &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;base58&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
  -encoding string
        one of: raw, hex, base58, base64 &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;default &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;base58&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
  -h    display help message &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;shorthand&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
  -help
        display help message
  -l int
        checksums length in bits &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;truncate&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;. -1 is default &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;shorthand&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;default -1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
  -length int
        checksums length in bits &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;truncate&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;. -1 is default &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;default -1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
  -q    quiet output &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;no newline on checksum, no error text&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;shorthand&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
  -quiet
        quiet output &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;no newline on checksum, no error text&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面我们尝试使用 multihash 对一个文件进行校验计算。首先新建一个 enp.txt 文件，输入内容为 “正道成功，EPN”，再执行 multihash epn.txt 命令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo &amp;quot;正道成功，EPN&amp;quot; &amp;gt; epn.txt
$ multihash epn.txt
$ QmbftC2aCSGeFLWu995pBGpMvQGgWoMXBxZG2JxDYd9GLP
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;multihash-计算过程探究&#34;&gt;multihash 计算过程探究&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;首先对内容进行 sha2-256 HASH 计算。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ shasum -a &lt;span style=&#34;color:#ae81ff&#34;&gt;256&lt;/span&gt; epn.txt
$ c6153579704c93e8d7fbcfbb639b99213c0a6d8397facd0a58d2fc8f4d5dd2e0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;multihash 格式封装： 加上 sha2-256 的编码以及 HASH 长度得到的字符串为 1220c6153579704c93e8d7fbcfbb639b99213c0a6d8397facd0a58d2fc8f4d5dd2e0。&lt;/li&gt;
&lt;li&gt;base58 编码： base58 最早使用在 btc 钱包地址上，它相对于传统的 base64 而言，去除了某些不和谐，阅读不友好的字符，例如 +/-,O/0 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ pip install base58
$ python
  
&amp;gt;&amp;gt;&amp;gt; import base58
&amp;gt;&amp;gt;&amp;gt; base58.b58encode_int&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;int&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1220c6153579704c93e8d7fbcfbb639b99213c0a6d8397facd0a58d2fc8f4d5dd2e0&amp;#34;&lt;/span&gt;, 16&lt;span style=&#34;color:#f92672&#34;&gt;))&lt;/span&gt;
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;QmbftC2aCSGeFLWu995pBGpMvQGgWoMXBxZG2JxDYd9GLP&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，通过 python 编码得到的 base58 结果和直接使用 go-multihash 结果一致，都是 QmbftC2aCSGeFLWu995pBGpMvQGgWoMXBxZG2JxDYd9GLP。&lt;/p&gt;
&lt;h2 id=&#34;multihash-与-ipfs&#34;&gt;multihash 与 IPFS&lt;/h2&gt;
&lt;p&gt;经常使用 IPFS 的人可能会发现其内容 HASH 都是以 Qm 开头，这和我们刚使用 go-multihash 计算的一致，这是因为 IPFS 直接使用了multihash 的默认选项，即 sha2-256 + base58。&lt;/p&gt;
&lt;p&gt;我们尝试使用 ipfs 命令计算  epn.txt 的 HASH 值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ipfs add epn.txt
added QmarcwWsQp5ew7jnFtqYTLgkWEWaMPde8gme5ApZQXvZkU epn.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你会发现使用 ipfs 计算得出的 HASH 和直接使用 go-multihash 计算的不同，这是因为 ipfs 对内容进行 sha2-256 计算的时候，会对内容进行一定的加工（首尾添加特定字节），这点可以使用 ipfs object get 来查看。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ipfs object get QmarcwWsQp5ew7jnFtqYTLgkWEWaMPde8gme5ApZQXvZkU
&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Links&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Data&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\u0008\u0002\u0012\u0013正道成功，EPN\n\u0018\u0013&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以使用 multihash 对 ipfs 加工后的内容重新进行计算：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ipfs block get QmarcwWsQp5ew7jnFtqYTLgkWEWaMPde8gme5ApZQXvZkU &amp;gt; epn-ipfs.txt
$ multihash epn-ipfs.txt
QmarcwWsQp5ew7jnFtqYTLgkWEWaMPde8gme5ApZQXvZkU
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到此时计算出的 HASH 值与 IPFS 计算出的保持一致。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;我们通过实际例子对 multihash 的格式，计算过程有深刻认识，其次我们还可以发现 ipfs 与 multihash 之间的内在联系，总而言之 IPFS 内容 HASH 计算过程可以大致看成 内容封装 &amp;gt; hash2-256 计算 &amp;gt; multihash 格式封装 &amp;gt; base58 编码。&lt;/p&gt;
&lt;p&gt;参考链接: &lt;a href=&#34;https://zhuanlan.zhihu.com/p/43853989&#34;&gt;https://zhuanlan.zhihu.com/p/43853989&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IPFS peer 扩容方案</title>
      <link>/posts/ipfs-peer-kuo-rong-fang-an/</link>
      <pubDate>Wed, 10 Oct 2018 19:44:33 +0800</pubDate>
      
      <guid>/posts/ipfs-peer-kuo-rong-fang-an/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;我们都知道 IPFS 默认安装在 ~/.ipfs 目录，存储空间(StorageMax) 为 10GB， 这显然无法满足生产环境的需求，毕竟现在一个机械硬盘动则就是几个TB。那我们该如何对 IPFS 单一节点的容量进行扩充，做到同时使用多个硬盘？&lt;/p&gt;
&lt;h2 id=&#34;环境&#34;&gt;环境&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Linux 系统&lt;/li&gt;
&lt;li&gt;三个物理硬盘盘分别为 /dev/vda1(系统盘)，/dev/vdb1（100GB），/dev/vdc1(100GB)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;方案&#34;&gt;方案&lt;/h2&gt;
&lt;p&gt;步骤1:  使用 LVM 将两个物理硬盘 /dev/vdb1 和 /dev/vdc1 组成同一物理卷组，最后再再物理卷组中创建逻辑卷组 （LV），具体命令如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 创建物理卷（PV）&lt;/span&gt;
pvcreate /dev/sdb1
pvcreate /dev/sdc1
  
&lt;span style=&#34;color:#75715e&#34;&gt;# 查看已经创建好的物理卷&lt;/span&gt;
pvdisplay
  
&lt;span style=&#34;color:#75715e&#34;&gt;# 创建物理卷组&lt;/span&gt;
vgcreate IPFS /dev/sdb1 /dev/sdc1
  
&lt;span style=&#34;color:#75715e&#34;&gt;#创建逻辑卷（LV）&lt;/span&gt;
lvcreate -L 195G IPFS -n IPFS
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时，现在你的逻辑卷应该已经在 /dev/mapper/ 和 &lt;em&gt;/dev/YourVolumeGroupName&lt;/em&gt; 中了。&lt;/p&gt;
&lt;p&gt;步骤2:  挂载到目录 /IPFS ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;mkdir /IPFS
mkfs.ext4 /dev/mapper/VolGroup00-lvolhome
mount /dev/mapper/VolGroup00-lvolhome /IPFS
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;步骤3: 设置环境变量 IPFS_PATH, 指向挂在的目录：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;export IPFS_PATH&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;/IPFS
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;步骤4:  ipfs 初始化、配置、启动应用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ipfs init
vi /IPFS/config &lt;span style=&#34;color:#75715e&#34;&gt;# 修改 StorageMax 参数，设置大小为 190GB，具体按照自己的磁盘大小设置。&lt;/span&gt;
ipfs daemon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时你将看到 ipfs 运行在了 /IPFS 目录，并且所有数据 blocks 存储在了 /IPFS/blocks ， 整个 ipfs 可以用的数据空间为 190 GB。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;我们通过 LVM 将多个物理硬盘连成物理硬盘组，再将磁盘组划分为一个大容量的逻辑卷，并将该卷挂载到我们的 IPFS_PATH 目录，从而使 IPFS 节点可以同时使用多个硬盘的存储空间。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IPFS GC研究</title>
      <link>/posts/ipfs-cun-chu-kong-jian-gc/</link>
      <pubDate>Tue, 25 Sep 2018 16:26:01 +0800</pubDate>
      
      <guid>/posts/ipfs-cun-chu-kong-jian-gc/</guid>
      <description>&lt;p&gt;众所周知 IPFS 节点（peer）在初始化以后，默认使用的存储空间是 10GB（ipfs config show 可以查看），但随着 peer 节点加入网络的时间越来越久，存储空间使用率会逐步增加，直到达到上限，此时该节点将不再提供存储功能（但还能提供老数据的网络请求服务）。&lt;/p&gt;
&lt;h2 id=&#34;gc-猜想&#34;&gt;GC 猜想&lt;/h2&gt;
&lt;p&gt;对于这种情况，其实 IPFS 是提供了 GC 机制的，这个可以从 ipfs config 的  &lt;code&gt;StorageGCWatermark&lt;/code&gt; 参数得出。只是 GC 默认被关闭了，需要使用 &lt;code&gt;ipfs daemon --enable-gc&lt;/code&gt; 来启动，我们还可以使用 &lt;code&gt;ipfs repo gc&lt;/code&gt; 来手动 GC 。&lt;/p&gt;
&lt;p&gt;猜想： 存储空间主要使用在两个方面，主动添加的内容（pined content）和节点访问而 Cache 的内容，当执行 GC 的时候，只删除 Cache 部分的内容，而被 pin 的内容应该被保留。&lt;/p&gt;
&lt;h2 id=&#34;猜想验证&#34;&gt;猜想验证&lt;/h2&gt;
&lt;p&gt;实验环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IPFS 私网搭建，参考&lt;a href=&#34;https://zhuanlan.zhihu.com/p/35141862&#34;&gt;链接&lt;/a&gt; 。&lt;/li&gt;
&lt;li&gt;两台虚拟机。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此时两台虚拟机构建一个 IPFS 私网，它们分别为 ipfs01 和 ipfs02，数据只会在它们之间共享。&lt;/p&gt;
&lt;h3 id=&#34;实验过程&#34;&gt;实验过程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;step 1. 在 ipfs01 添加一张照片，然后执行 &lt;code&gt;ipfs pin | grep $HASH&lt;/code&gt; 查看是否已经 pined。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs_gc01.png&#34; alt=&#34;gc01&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Tips:  通过 ipfs add 命令的时候，内容会直接被 pined。&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;step 2. 在 ipfs02 中通过命令 &lt;code&gt;ipfs cat $HASH &amp;gt; cat.jpg&lt;/code&gt;  来下载该文件，然后执行 &lt;code&gt;ipfs pin | grep $HASH&lt;/code&gt; 查看是否 pined。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs_gc02.png&#34; alt=&#34;gc02&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过 ipfs cat 把 ipfs01 中的 cat.jpg 下载到了 ipfs02 ，我们可以通过浏览器查看其内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs_gc03.png&#34; alt=&#34;gc03&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Tips:  内容只是被缓存，并没有 pined。&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;step3 : 将 ipfs01 中的 $HASH unpin, 并在本地执行 &lt;code&gt;ipfs repo gc&lt;/code&gt; ，可以看到 该 $HASH 被清除：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs_gc04.png&#34; alt=&#34;gc04&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;step 4: 在 ipfs01 中重复执行 step 2 步骤：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs_gc05.png&#34; alt=&#34;gc05&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Tips:  可以看到 ipfs01 可以从 ipfs02 缓存节点中读取内容并保存。&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;step 5:  在两台机器中分别执行 &lt;code&gt;ipfs repo gc&lt;/code&gt; 后，再执行 &lt;code&gt;ipfs cat $HASH&lt;/code&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs_gc06.png&#34; alt=&#34;gc06&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Tips: 可以看到分别执行 gc 后，所有的缓存备份都被删除，故在全网中都无法搜索到内容，直到最后超时。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论：&lt;/h2&gt;
&lt;p&gt;通过实验，验证了我们的猜想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先 IPFS 存在 GC ，其次它只 GC  Cache 内容(即 unpin)。&lt;/li&gt;
&lt;li&gt;因为默认 GC 不开启，此时 cached 和 pined 内容等效。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>IPFS 三端可用性调研</title>
      <link>/posts/ipfs-zai-san-duan-ke-yong-xing-diao-yan/</link>
      <pubDate>Wed, 19 Sep 2018 16:03:24 +0800</pubDate>
      
      <guid>/posts/ipfs-zai-san-duan-ke-yong-xing-diao-yan/</guid>
      <description>&lt;h2 id=&#34;三端指什么&#34;&gt;三端指什么&lt;/h2&gt;
&lt;p&gt;三端指浏览器，Android, iOS ，当前绝大多数互联网应用都跑在这三个终端上，所以 IPFS 在它们上的运行成熟度直接决定了 IPFS 最终流行程度，我们有必要提前了解并做好准备。&lt;/p&gt;
&lt;h2 id=&#34;浏览器&#34;&gt;浏览器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;状态： 可行&lt;/li&gt;
&lt;li&gt;语言： JS&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ipfs/in-web-browsers&#34;&gt;https://github.com/ipfs/in-web-browsers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ipfs/js-ipfs&#34;&gt;https://github.com/ipfs/js-ipfs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;android&#34;&gt;Android&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;状态： 可行&lt;/li&gt;
&lt;li&gt;语言：kotlin&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ligi/ipfs-api-kotlin&#34;&gt;https://github.com/ligi/ipfs-api-kotlin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ligi/IPFSDroid&#34;&gt;https://github.com/ligi/IPFSDroid&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ios&#34;&gt;iOS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;状态： 可行&lt;/li&gt;
&lt;li&gt;语言： swift&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ipfs/swift-ipfs-api&#34;&gt;https://github.com/ipfs/swift-ipfs-api&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，社区很多人都在三端进行尝试，都希望 IPFS 能够在更多的平台上进行运行，尤其是移动端，这样可以大大扩充节点的数量。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IPFS 生态概览</title>
      <link>/posts/ipfs-sheng-tai-gai-lan/</link>
      <pubDate>Wed, 22 Aug 2018 15:27:35 +0800</pubDate>
      
      <guid>/posts/ipfs-sheng-tai-gai-lan/</guid>
      <description>&lt;p&gt;要想全面了解 IPFS 就不得不提 &lt;a href=&#34;https://protocol.ai/work/&#34;&gt;Protocal labs&lt;/a&gt;，目前它主要的项目包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ipfs.io/&#34;&gt;IPFS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://filecoin.io/&#34;&gt;Filecoin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://libp2p.io/&#34;&gt;libp2p&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ipld.io/&#34;&gt;IPLD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://multiformats.io&#34;&gt;Multiformats&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那为什么会有这些项目，这些项目产生的背景，以及最核心的功能又是什么？看完本篇概览，你就会找到答案。&lt;/p&gt;
&lt;h2 id=&#34;ipfs&#34;&gt;IPFS&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;IPFS is a new protocol to decentralize the web. IPFS enables the creation of completely decentralized and distributed applications, using content addressing and digital signatures。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;IPFS是一种去中心化网络的新协议。 IPFS支持使用内容寻址和数字签名创建完全去中心化的分布式应用程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到， IPFS 主要作为一种网络协议，使得通过它构建完全去中心的分布式应用程序（DApp）成为可能（当然还有其他的方式，例如 ETH），但是就像传统中心化的应用，DApp 对于永久可靠性存储的需求一直都在，并且成为 DApp 能够爆发的关键一环，当然也直接决定了 IPFS 协议最终的成功。&lt;/p&gt;
&lt;p&gt;虽然已经有不少去中心化存储网络(DSN)解决方案，但是介于方案的成熟度，性能，以及与 IPFS 整合能力各方面的考量，由 Protocal labs 自己来实现 Filecoin 的方案才是最靠谱的。这样也会大量利用到 IPFS 已有的技术，例如底层网络连接和数据交换（libp2p）以及去中心化数据的通用定义（IPLD）。&lt;/p&gt;
&lt;p&gt;在 IPFS 技术栈中不得不提 ipfs-cluster, 它是 IPFS 的 Pinset 编排程序，通过它可以构建更大的容量的 IPFS PinSet 集群，利用它可以构建一个去中心化的永久存储系统。个人认为它和 Filecoin 关注的重点不同，因为 Filecoin 是在公链中构建带有存储激励的存储网络，而 ipfs-cluster 相当于通过自己可控的节点构建超大的 IPFS PinSet 集群，而且目前 ipfs-cluster 的成熟度高于 Filecoin。&lt;/p&gt;
&lt;h2 id=&#34;filecoin&#34;&gt;Filecoin&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Filecoin is a cryptocurrency powered storage network. Miners earn Filecoin by providing open hard-drive space to the network, while users spend Filecoin to store their files encrypted in the decentralized network.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Filecoin 是一种加密货币驱动的存储网络。 矿工通过向网络提供开放的硬盘空间来获得Filecoin，而用户使用Filecoin来存储他们在分散网络中加密的文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;DApp 是需要大量永久性去中心化存储的，这一点 IPFS 无法满足，所以 Filecoin 孕育而生，而且通过 FileCoin + IPFS 可以很好的解决整个 DApp 的内容存储和分发问题。&lt;/p&gt;
&lt;h2 id=&#34;libp2p&#34;&gt;libp2p&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;libp2p is a modular networking stack. libp2p brings together a variety of transports and peer-to-peer protocols, making it easy for developers to build large, robust p2p networks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;libp2p 是一个模块化的网络技术栈。 libp2p汇集了各种传输和点对点协议，使开发人员可以轻松构建大型，强大的 p2p 网络。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前去中心化的网络都是基于 p2p 来构建的，例如 BTC, ETH 和 IPFS, 因为 IPFS 包含了一个强大的 p2p 网络，那么将它抽离出来,成为一个单独的项目，能够被其它开源项目所复用是非常有价值的。&lt;/p&gt;
&lt;h2 id=&#34;ipld&#34;&gt;IPLD&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;IPLD is the data model for the Decentralized Web. It connects all data through cryptographic hashes, and makes it easy to traverse and link to.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;IPLD是去中心化 Web 的数据模型。 它通过加密哈希连接所有数据，并使其易于遍历和链接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;IPFS 属于去中心化的 Web 协议，那么底层就依赖 IPLD，这样的数据结构能够在各种去中心的网络中实现数据共享和互访，例如（IPFS 和 ETH，BTC 等）。&lt;/p&gt;
&lt;h2 id=&#34;multiformats&#34;&gt;Multiformats&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;The Multiformats Project is a collection of protocols to future-proof systems, today. Self-describing formats make your systems interoperable and upgradable.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Multiformats 项目是当今面向未来系统的协议集合。 自描述的格式使你的系统可互操作和可升级。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Multiformats 主要强调其自描述性，故名思议可以通过格式就能知道其中含义，那么作为一组协议集合，它目前包含了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;multihash：自描述的 hash，主要用于 IPFS 中对于内容加密 hash 的描述。&lt;/li&gt;
&lt;li&gt;multiaddr：自描述的网络地址，主要用于 libp2p 的网络地址描述。&lt;/li&gt;
&lt;li&gt;multibase： 自我识别的基础编码。&lt;/li&gt;
&lt;li&gt;multicodec： 自描述序列化。&lt;/li&gt;
&lt;li&gt;multistream： 字描述的流式网络协议。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;IPFS 的目标是要在去中心化网络中主流（甚至唯一）的网络协议（类似 Web 中的 HTTP 的地位），但只有 IPFS协议显然是不够的，去中心化应用（网络）的普及，需要整个生态的共同发展，所以才有了后来的去中心化的数据模型（IPLD），去中心化的字描述数据格式（Multiformats），去中心化的永久性存储（FileCoin) 以及快速构建大型 p2p 应用的 libp2p 。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IPFS 二维码添加的问题</title>
      <link>/posts/ipfs-er-wei-ma-tian-jia-de-wen-ti/</link>
      <pubDate>Thu, 09 Aug 2018 21:01:37 +0800</pubDate>
      
      <guid>/posts/ipfs-er-wei-ma-tian-jia-de-wen-ti/</guid>
      <description>&lt;p&gt;前段时间在知乎上看到「飞向未来」大大早期文章 &lt;a href=&#34;https://zhuanlan.zhihu.com/p/32651288&#34;&gt;什么是IPFS?(三)&lt;/a&gt; 中有这样一段描述：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs/ipfs03.png&#34; alt=&#34;ipfs03.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是真的是这样吗？难道我们真的没有办法在一个网站中插入对应二维码？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;结论当然是可以，因为我们有 IPNS。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面我将介绍具体的实现步骤：&lt;/p&gt;
&lt;h3 id=&#34;step-1--占坑&#34;&gt;Step 1:  占坑&lt;/h3&gt;
&lt;p&gt;创建一个目录，添加到 IPFS 网络，先做好 IPNS 映射，这个过程就相当于在逻辑上先定义一个网站。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir demo
$ ipfs add -r demo

added QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn demo
 0 B / 68 B [---------------------------------------------------------------------------]   0.00%

$ ipfs name public QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn
Published to QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe: /ipfs/QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时我们已经可以通过 ipns/QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe 来访问网站了。&lt;/p&gt;
&lt;h3 id=&#34;step-2-添加网页&#34;&gt;Step 2: 添加网页&lt;/h3&gt;
&lt;p&gt;在 demo 目录下创建 &lt;code&gt;a.html&lt;/code&gt; 文件，并且在 &lt;code&gt;a.html&lt;/code&gt; 中添加如下内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;charset&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;UTF-8&amp;#34;&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;qrcode demo&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;style&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;text-align:center;&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;h1&lt;/span&gt;&amp;gt;this is a ipfs page with qrcode&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;h1&lt;/span&gt;&amp;gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;br&lt;/span&gt;/&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;img&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;a.png&amp;#34;&lt;/span&gt; /&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;step-3添加二维码&#34;&gt;Step 3：添加二维码&lt;/h3&gt;
&lt;p&gt;随便找一个二维码生成器生成 &lt;code&gt;a.html&lt;/code&gt; 对应 IPNS 二维码，并存放为 &lt;code&gt;demo/a.png&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs/ipns01.png&#34; alt=&#34;ipns01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;此时 &lt;code&gt;demo&lt;/code&gt; 目录结构是这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ tree demo/

demo/
├── a.png
└── a.html

&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; directories, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;step-4-更新并发布网站&#34;&gt;Step 4: 更新并发布网站&lt;/h3&gt;
&lt;p&gt;依次执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs add -r demo

added QmNU5XXUpDnAXv88nDTcafKFY3h5LhKLJnkf2XBBGtc8wW demo/a.html
added QmcZhDddySHAdaJa9zKBRkY9SBrDJTWsq5Fn5chCDPXz3j demo/a.png
added QmSUCYnZ6SrGaAs8gaAAmf5tgjYAGMKjwMX3r4k7FxvCx1 demo
 2.23 KiB / 2.36 KiB [==============================================================&amp;gt;---]  94.37%

$ ipfs name publish QmSUCYnZ6SrGaAs8gaAAmf5tgjYAGMKjwMX3r4k7FxvCx1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后打开浏览器访问地址 &lt;a href=&#34;https://ipfs.io/ipns/QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe/a.html&#34;&gt;https://ipfs.io/ipns/QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe/a.html&lt;/a&gt; 将看到刚发布的 &lt;code&gt;a.html&lt;/code&gt; 页面，并包含对应二维码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs/ipns02.png&#34; alt=&#34;ipns02.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;到此为止，这个先有鸡还是先有蛋的问题已被我们解决，通过此例可以让我们加深对 IPNS 的认识。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 IPFS 搭建个人博客</title>
      <link>/posts/shi-yong-ipfs-da-jian-ge-ren-bo-ke/</link>
      <pubDate>Wed, 08 Aug 2018 20:35:00 +0800</pubDate>
      
      <guid>/posts/shi-yong-ipfs-da-jian-ge-ren-bo-ke/</guid>
      <description>&lt;p&gt;本文主要讲解如何使用 IPFS 搭建个人博客，从而实现个人博客在网络中的“永生”。&lt;/p&gt;
&lt;p&gt;主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IPFS 简介&lt;/li&gt;
&lt;li&gt;IPFS 安装和基本使用&lt;/li&gt;
&lt;li&gt;IPFS 的内容发布&lt;/li&gt;
&lt;li&gt;IPNS 的内容发布&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ipfs-简介&#34;&gt;IPFS 简介&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://ipfs.io/&#34;&gt;IPFS&lt;/a&gt; 是 InterPlanetary File System 的简称，中文名叫星际文件系统，是一个旨在创建持久且分布式存储和共享文件的网络传输协议。&lt;/p&gt;
&lt;p&gt;它是一种内容可寻址的对等超媒体分发协议，在 IPFS 网络中的所有节点将构成一个分布式文件系统，使用点对点的超媒体协议，从而让网络更快、更安全、更开放。&lt;/p&gt;
&lt;h3 id=&#34;ipfs-安装&#34;&gt;IPFS 安装&lt;/h3&gt;
&lt;p&gt;访问页面 &lt;a href=&#34;https://github.com/ipfs/go-ipfs/releases&#34;&gt;https://github.com/ipfs/go-ipfs/releases&lt;/a&gt; 下载对应版本，解压，运行安装文件即可。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ wget https://github.com/ipfs/go-ipfs/releases/download/v0.4.17/go-ipfs_v0.4.17_darwin-amd64.tar.gz

$ tar xvf go-ipfs_v0.4.17_darwin-amd64.tar.gz
$ cd go-ipfs &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; ./install.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;安装成功后，执行 &lt;code&gt;ipfs version&lt;/code&gt; 你将看到类似内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ipfs version

ipfs version 0.4.17
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令 &lt;code&gt;ipfs -h&lt;/code&gt; 来查看更多命令&lt;/li&gt;
&lt;li&gt;命令 &lt;code&gt;cat ~/.ipfs/config&lt;/code&gt; 可以查看所有默认配置项&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;新建-ipfs-节点&#34;&gt;新建 IPFS 节点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;运行 &lt;code&gt;ipfs init&lt;/code&gt; 初始化节点&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ipfs init
initializing IPFS node at /Users/sjy/.ipfs
generating 2048-bit RSA keypair...done
peer identity: QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe
to get started, enter:

	ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;初始化成功后，可以使用 &lt;code&gt;ipfs cat&lt;/code&gt; 命令来查看 IPFS 网络中的文件，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme
Hello and Welcome to IPFS!

██╗██████╗ ███████╗███████╗
██║██╔══██╗██╔════╝██╔════╝
██║██████╔╝█████╗  ███████╗
██║██╔═══╝ ██╔══╝  ╚════██║
██║██║     ██║     ███████║
╚═╝╚═╝     ╚═╝     ╚══════╝

If you&#39;re seeing this, you have successfully installed
IPFS and are now interfacing with the ipfs merkledag!

 -------------------------------------------------------
| Warning:                                              |
|   This is alpha software. Use at your own discretion! |
....
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;ipfs id&lt;/code&gt; 查看节点基本信息&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs id

{
	&amp;quot;ID&amp;quot;: &amp;quot;QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe&amp;quot;,
	&amp;quot;PublicKey&amp;quot;: &amp;quot;...&amp;quot;,
	&amp;quot;Addresses&amp;quot;: [
		&amp;quot;/ip4/127.0.0.1/tcp/4001/ipfs/QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe&amp;quot;,
		&amp;quot;/ip4/100.100.58.79/tcp/4001/ipfs/QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe&amp;quot;,
		&amp;quot;/ip4/100.100.6.124/tcp/4001/ipfs/QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe&amp;quot;,
		&amp;quot;/ip6/::1/tcp/4001/ipfs/QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe&amp;quot;,
		&amp;quot;/ip4/103.20.32.163/tcp/4001/ipfs/QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe&amp;quot;
	],
	&amp;quot;AgentVersion&amp;quot;: &amp;quot;go-ipfs/0.4.17/&amp;quot;,
	&amp;quot;ProtocolVersion&amp;quot;: &amp;quot;ipfs/0.1.0&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;运行 &lt;code&gt;ipfs daemon&lt;/code&gt; 连接网络&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs daemon
Initializing daemon...
Swarm listening on /ip4/100.100.58.79/tcp/4001
Swarm listening on /ip4/100.100.6.124/tcp/4001
Swarm listening on /ip4/127.0.0.1/tcp/4001
Swarm listening on /ip6/::1/tcp/4001
Swarm listening on /p2p-circuit/ipfs/QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe
Swarm announcing /ip4/100.100.58.79/tcp/4001
Swarm announcing /ip4/100.100.6.124/tcp/4001
Swarm announcing /ip4/127.0.0.1/tcp/4001
Swarm announcing /ip6/::1/tcp/4001
Error: serveHTTPApi: manet.Listen(/ip4/127.0.0.1/tcp/5001) failed: listen tcp4 127.0.0.1:5001: bind: address already in use
Received interrupt signal, shutting down...
(Hit ctrl-c again to force-shutdown the daemon.)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有时你会遇到端口冲突的问题，可以使用 &lt;code&gt;vi ~/.ipfs/config&lt;/code&gt; 修改默认配置来解决，相关内容为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// from
&amp;quot;API&amp;quot;: &amp;quot;/ip4/127.0.0.1/tcp/5001&amp;quot;,
&amp;quot;Gateway&amp;quot;: &amp;quot;/ip4/127.0.0.1/tcp/8080&amp;quot;

// to 
&amp;quot;API&amp;quot;: &amp;quot;/ip4/127.0.0.1/tcp/9091&amp;quot;,
&amp;quot;Gateway&amp;quot;: &amp;quot;/ip4/127.0.0.1/tcp/9090&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;保存修改后，再次运行 &lt;code&gt;ipfs daemon&lt;/code&gt;，可以看到如下输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs daemon

Initializing daemon...
Swarm listening on /ip4/100.100.58.79/tcp/4001
Swarm listening on /ip4/100.100.6.124/tcp/4001
Swarm listening on /ip4/127.0.0.1/tcp/4001
Swarm listening on /ip6/::1/tcp/4001
Swarm listening on /p2p-circuit/ipfs/QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe
Swarm announcing /ip4/100.100.58.79/tcp/4001
Swarm announcing /ip4/100.100.6.124/tcp/4001
Swarm announcing /ip4/127.0.0.1/tcp/4001
Swarm announcing /ip6/::1/tcp/4001
API server listening on /ip4/127.0.0.1/tcp/9091
Gateway (readonly) server listening on /ip4/127.0.0.1/tcp/9090
Daemon is ready
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后打开浏览器访问 &lt;code&gt;http://localhost:9091/webui&lt;/code&gt; 可以看到如下内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs/webui.png&#34; alt=&#34;webui&#34;&gt;&lt;/p&gt;
&lt;p&gt;这说明我们已经成功加入 IPFS 网络。&lt;/p&gt;
&lt;h3 id=&#34;添加个人博客&#34;&gt;添加个人博客&lt;/h3&gt;
&lt;p&gt;长期以来我都是使用 Jekyll 来写博客，这里就用它来示范，当然大家也可以使用其它静态网站生成器，例如（hugo）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;jekyll build&lt;/code&gt; 生成最新博客内容&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;ipfs add -r _site&lt;/code&gt; 添加博客站&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs add -r _site

added QmRum1Gg9DjYm8xosqaEd2YMdYZaVjUqifNC7xEQcxgCyn _site/404.html
added QmXMGUT9SMFa9nx4FcN5AQmPV4GBChAzUNzN2KUqJSQb5Q _site/CNAME
added Qme8R4NpB93Tcy55vhZhgReCkaehfhB6NGcMyHWFhNjGvJ _site/Gemfile
added QmPWR1QN9wVUtBGUm6PhwpwhuRHQXttrHufm6y8AYWzP4p _site/Gemfile.lock
added QmXWVVA17LnCZMqsTx75hZDeFhoJRJeKWEeU3dufQUkhmo _site/LICENSE
added Qmdvx2PCV3kQD8PvCFtsCi68mapc1fpkgS8FrQod42HxWh _site/README.md
added QmRHRq49njYPheLBMV8RTCnuDWcapkwRBhVNWXQPvThUyh _site/about.html
added QmPmmp8C2BaLvhFb2M43xdTgvUAtV5xREG2AAMiNpfgF2A _site/feed.xml
added QmPE53kbhLfSPUdAkieGR4NB6aA79ojkcQVB5WgksgiCoi _site/images/404.png
.....
added QmZw6t1FiWMMKgB5o4KohJ7wqHDvHRRBRvc8FmRwshejpR _site
58.51 MiB / 116.73 MiB [===========================================&amp;gt;------------------------------------------]  50.13% 00m03s
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到整个网站以 &lt;code&gt;_site&lt;/code&gt; 为根目录，当前的版本为 &lt;code&gt;QmZw6t1FiWMMKgB5o4KohJ7wqHDvHRRBRvc8FmRwshejpR&lt;/code&gt;，然后我们就可以通过链接 &lt;code&gt;https://ipfs.io/ipfs/QmZw6t1FiWMMKgB5o4KohJ7wqHDvHRRBRvc8FmRwshejpR&lt;/code&gt; 在浏览器中查看到最新的博客内容了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs/ipfs01.jpg&#34; alt=&#34;ipfs01.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;发布到-ipns&#34;&gt;发布到 IPNS&lt;/h3&gt;
&lt;p&gt;当博客更新后，会生成新的 hash，要访问最新版本的内容就需要新生成的 hash，那如何使用一个固定的链接来访问最新版本的内容呢？&lt;/p&gt;
&lt;p&gt;这就需要使用到 IPNS，IPNS 是 IPFS 的命名系统，它允许用户使用一个私有密钥来对哈希附加一个引用，使用一个公共密钥哈希（简称 pubkeyhash）表示你的网站的最新版本。&lt;/p&gt;
&lt;p&gt;具体操作如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs name publish QmZw6t1FiWMMKgB5o4KohJ7wqHDvHRRBRvc8FmRwshejpR

Published to QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe: /ipfs/QmZw6t1FiWMMKgB5o4KohJ7wqHDvHRRBRvc8FmRwshejpR
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行完命令后，我们就完成了博客和一个固定的 link 的绑定，我们可以使用 &lt;code&gt;ipfs name resolve xxx&lt;/code&gt; 来查看固定 link 绑定的版本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs name resolve QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe

/ipfs/QmZw6t1FiWMMKgB5o4KohJ7wqHDvHRRBRvc8FmRwshejpR
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后我们通过 ipns + 生成的固定 hash （QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe）来访问博客了，例如:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs/ipfs02.jpg&#34; alt=&#34;ipfs02.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;当我们博客有更新的时候，只需要再次执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ jekyll build
$ ipfs add -r _site
$ ipfs name publish &amp;lt;最新 hash&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并使用固定的 IPNS hash  &lt;code&gt;QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe&lt;/code&gt; 来访问即可。&lt;/p&gt;
&lt;p&gt;至此，我们基本完成了个人博客的 IPFS 发布，最后就剩的个人域名的绑定了，这个留到后面的文章来讲解。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;我们通过 IPFS 的安装、创建网络节点、添加网站、发布固定网站，学习了 IPFS 基础概念、基本操作、基于内容寻址的访问方式、以及 IPNS 和 IPFS 的对应关系。&lt;/p&gt;
&lt;p&gt;可以看到使用 IPFS 搭建个人博客，乃至 WIKI 等内容网站是非常高效的，大家不妨尝试一下。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>