<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ipfs on FILVIP</title>
    <link>/tags/ipfs/</link>
    <description>FILVIP (ipfs)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 18 Jan 2019 16:10:41 +0800</lastBuildDate>
    
    <atom:link href="/tags/ipfs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>IPFS cat 命令详解</title>
      <link>/posts/ipfs-cat-ming-ling-xiang-jie/</link>
      <pubDate>Fri, 18 Jan 2019 16:10:41 +0800</pubDate>
      
      <guid>/posts/ipfs-cat-ming-ling-xiang-jie/</guid>
      <description>&lt;h2 id=&#34;命令介绍&#34;&gt;命令介绍&lt;/h2&gt;
&lt;p&gt;我们可以使用 &lt;code&gt;ipfs cat&lt;/code&gt; 命令直接查看一个文件对象（object）的内容，也可以使用 IO 重定向 &lt;code&gt;&amp;gt;&lt;/code&gt; 来进行下载，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ipfs cat QmWBbKvLhVnkryKG6F5YdkcnoVahwD7Qi3CeJeZgM6Tq68 &amp;gt; 神秘巨星.mp4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;备注： 资源来自&lt;a href=&#34;https://zhuanlan.zhihu.com/p/35342854&#34;&gt;链接&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat&lt;/code&gt; 命令支持 -o 和 -l 参数，分别表示文件读取的偏移量（offset）以及读取文件内容的长度，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ipfs cat QmWBbKvLhVnkryKG6F5YdkcnoVahwD7Qi3CeJeZgM6Tq68 -o &lt;span style=&#34;color:#ae81ff&#34;&gt;256&lt;/span&gt; -l &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注： 表示从文件 QmWBbKvLhVnkryKG6F5YdkcnoVahwD7Qi3CeJeZgM6Tq68 的第 256 个字节开始，查看10个字节的内容，这个功能很好用，我们可以用它来实现分片下载以及断点续传等功能。&lt;/p&gt;
&lt;h2 id=&#34;ipfs-文件组织方式&#34;&gt;IPFS 文件组织方式&lt;/h2&gt;
&lt;p&gt;在具体讲解 cat 命令的实现逻辑之前，我们先来了解下 IPFS 文件对象的组织方式，其实 IPFS 对象是一棵树，每个节点下面最多包含174个 Links(字节点)。文件对象的节点主要分类两种(Data_File 和 Data_Raw), 只有最下面的叶子节点才会存储真实的数据（Data_Raw），其它节点只是数据节点的元信息，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs_cat01.png&#34; alt=&#34;object.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;注： 红色（Data_File）、绿色（Data_Raw）。&lt;/p&gt;
&lt;p&gt;我们可以 QmWBbKvLhVnkryKG6F5YdkcnoVahwD7Qi3CeJeZgM6Tq68 为例，通过 &lt;code&gt;ipfs object get&lt;/code&gt; 命令来对照查看：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ipfs object get QmWBbKvLhVnkryKG6F5YdkcnoVahwD7Qi3CeJeZgM6Tq68

&lt;span style=&#34;color:#75715e&#34;&gt;# output&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; 
   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Links&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt; 
      &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; 
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Name&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;,
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hash&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;QmbmtXF9hZ6hLEubdLFP78MSPTWxUe78sYwjpCyiEJat3m&amp;#34;&lt;/span&gt;,
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Size&amp;#34;&lt;/span&gt;:45623854
      &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;, 
       ... 省略 &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt; 行 ...
 
      &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; 
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Name&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;,
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hash&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;QmXEqLu1hXe3MfDngRdV1yWmtFQbpVz1WyDHY17r6BbsYj&amp;#34;&lt;/span&gt;,
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Size&amp;#34;&lt;/span&gt;:31327573
      &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
   &lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;,
   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Data&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\u0008\u0002\u0018...&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到 &lt;code&gt;QmWBbKvLhVnkryKG6F5YdkcnoVahwD7Qi3CeJeZgM6Tq68&lt;/code&gt; 总共包含了 34 个 Link ，其中前 33 个 Link 的数据大小都为 45623854 ，最后一个大小为 31327573。然后我们再递归调用 &lt;code&gt;ipfs object get&lt;/code&gt; 分别获取所有 Link 的 内容，例如第一个 Link：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ipfs object get QmbmtXF9hZ6hLEubdLFP78MSPTWxUe78sYwjpCyiEJat3m

&lt;span style=&#34;color:#75715e&#34;&gt;# output&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; 
   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Links&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt; 
      &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; 
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Name&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;,
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hash&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;QmUgjKGQqNA4sJWbao2nBiANs46RjLAPaQrGLPHpR6Mh59&amp;#34;&lt;/span&gt;,
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Size&amp;#34;&lt;/span&gt;:262158
      &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;,
      ... 省略 &lt;span style=&#34;color:#ae81ff&#34;&gt;172&lt;/span&gt; 个...
      &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; 
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Name&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;,
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hash&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;QmSDaeEJ9ZsEGaFNx4ZMTAVcv8ncgMURKTjBeJ3gfhqkX9&amp;#34;&lt;/span&gt;,
         &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Size&amp;#34;&lt;/span&gt;:262158
      &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
   &lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;,
   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Data&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\u0008\u0002\u0018...&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到 &lt;code&gt;QmbmtXF9hZ6hLEubdLFP78MSPTWxUe78sYwjpCyiEJat3m&lt;/code&gt;  下面包含了 174 个文件，每个文件大小为 262158 字节，因为这些都是叶子节点，存储的都是真实的数据，而默认IPFS数据分片大小为 256KB，还添加了12个字节作为数据校准。再随意查看一个 Link ，可以看到它的实际内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ipfs object get QmUgjKGQqNA4sJWbao2nBiANs46RjLAPaQrGLPHpR6Mh59
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;/images/ipfs_cat02.png&#34; alt=&#34;store.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;到这一步，我们对IPFS文件对象的组织方式有了大概了解，那么接下来看看 cat 命令具体的实现逻辑。&lt;/p&gt;
&lt;h2 id=&#34;cat-命令实现逻辑&#34;&gt;Cat 命令实现逻辑&lt;/h2&gt;
&lt;p&gt;cat 命令的实现逻辑大致分为三步：&lt;/p&gt;
&lt;h3 id=&#34;step-1-参数解析&#34;&gt;Step 1: 参数解析&lt;/h3&gt;
&lt;p&gt;获得有效的 IPFS 或者 IPNS 对象的访问路径，例如上面的 &lt;code&gt;QmWBbKvLhVnkryKG6F5YdkcnoVahwD7Qi3CeJeZgM6Tq68&lt;/code&gt;
获得命令的运行参数，主要是 -o 和 -l&lt;/p&gt;
&lt;h3 id=&#34;step-2-递归下载-block-内容&#34;&gt;Step 2: 递归下载 Block 内容&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先获取 root cid 的内容，任何一个 cid 的内容获取过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据 cid 还原为 Block 文件 path,  先在 $IPFS_PATH/blocks/ 目录中查看文件是否存在，如果存在读取文件内容并解析。&lt;/li&gt;
&lt;li&gt;如果没有找到，尝试使用 cid 的 v1 版本，重复 1 的过程，如果没有找到，再通过 BlockService 在 bitswap p2p 网络中寻找，如果找到，进行 3），没有找到进行4）。&lt;/li&gt;
&lt;li&gt;解析内容，转化为 一个 ipld.Node ，并存储到本地的 blocks  内容中，并更新本地 BlockStorage 缓存。&lt;/li&gt;
&lt;li&gt;退出任务，提示失败。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当获取 root cid 内容的时候， IPFS 会将它封装了一个 file 对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;file 对象的读取是一个递归调用过程，直到内容读取完成或者对应长度。&lt;/li&gt;
&lt;li&gt;file 中定义了一个 4096 的缓冲区，将 Block 中的内容顺序 flush 给客户端。&lt;/li&gt;
&lt;li&gt;file 中的 Read 函数中定义了一个 precalcNextBuf 的函数，为了加快速度，该函数起了10个并发，可以同时从本地或者网络中准备好获取这10个Link 的内容到内存中（即使传入 -o、-l 参数），所以单个文件下载大约会消耗256KB * 10 = 2.5MB 内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据输入参数 -o 和 -l 设置文件读取的游标位置，主要调用 file.Seek() 函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上过程，我整理一个流程图，大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs_cat03.png&#34; alt=&#34;catflow.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IPFS 文件可以使用 -o -l 实现 range 下载。&lt;/li&gt;
&lt;li&gt;IPFS 对于单个文件是顺序下载的，在下载过程中会提前准备好10个 Blocks 的内容，所以单个文件下载最多消耗256KB*10=2.5MB 内存。&lt;/li&gt;
&lt;li&gt;下载消耗的总内存 = 总下载任务数 * 2.5MB。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>IPFS 中的 multihash</title>
      <link>/posts/ipfs-zhong-de-multihash/</link>
      <pubDate>Tue, 23 Oct 2018 19:28:20 +0800</pubDate>
      
      <guid>/posts/ipfs-zhong-de-multihash/</guid>
      <description>&lt;p&gt;在 &lt;a href=&#34;/posts/ipfs-sheng-tai-gai-lan&#34;&gt;IPFS 生态概览&lt;/a&gt; 一文中我们已经提到了 multihash，那我们就来看看在 IPFS 中是如何使用它的？&lt;/p&gt;
&lt;h2 id=&#34;为什么要用-multihash&#34;&gt;为什么要用 multihash&lt;/h2&gt;
&lt;p&gt;IPFS 默认使用的 HASH 算法是 sha2-256, 虽然现在 sha2-256 还算安全，但这并不意味它不会被攻破，随着算力的发展，说不定哪天就被破解了，所以 IPFS 需要一种可升级具有自描述的 HASH 格式，这就是 multihash。&lt;/p&gt;
&lt;h2 id=&#34;multihash-格式&#34;&gt;multihash 格式&lt;/h2&gt;
&lt;p&gt;multihash 的格式很简单，具体文档参见 &lt;a href=&#34;https://github.com/multiformats/multihash&#34;&gt;multiformats/multihash&lt;/a&gt;。它其实就是一个字符串，由三部分组成：HASH算法编码、HASH值的长度（字节数）、HASH 值 组成，形如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;varint hash function code&amp;gt;&amp;lt;varint digest size in bytes&amp;gt;&amp;lt;hash function output&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如：函数为 sha2-256，值为 32 位的 6cb42b2e29c28aeb143c3b9a0d9787f38ce2e5efea68ab01df6e121e4146ed8d 的 multihash 格式为：12206cb42b2e29c28aeb143c3b9a0d9787f38ce2e5efea68ab01df6e121e4146ed8d。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这里使用的是 sha2-256，其 HASH 编码为 0x12 ，multihash 中所有 HASH 算法编码如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// constants
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; (
   &lt;span style=&#34;color:#a6e22e&#34;&gt;ID&lt;/span&gt;         = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;SHA1&lt;/span&gt;       = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x11&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;SHA2_256&lt;/span&gt;   = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x12&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;SHA2_512&lt;/span&gt;   = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x13&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;SHA3_224&lt;/span&gt;   = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x17&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;SHA3_256&lt;/span&gt;   = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x16&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;SHA3_384&lt;/span&gt;   = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x15&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;SHA3_512&lt;/span&gt;   = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x14&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;SHA3&lt;/span&gt;       = &lt;span style=&#34;color:#a6e22e&#34;&gt;SHA3_512&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;KECCAK_224&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1A&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;KECCAK_256&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1B&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;KECCAK_384&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1C&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;KECCAK_512&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1D&lt;/span&gt;
 
   &lt;span style=&#34;color:#a6e22e&#34;&gt;SHAKE_128&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x18&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;SHAKE_256&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x19&lt;/span&gt;
 
   &lt;span style=&#34;color:#a6e22e&#34;&gt;BLAKE2B_MIN&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0xb201&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;BLAKE2B_MAX&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0xb240&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;BLAKE2S_MIN&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0xb241&lt;/span&gt;
   &lt;span style=&#34;color:#a6e22e&#34;&gt;BLAKE2S_MAX&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0xb260&lt;/span&gt;
 
   &lt;span style=&#34;color:#a6e22e&#34;&gt;DBL_SHA2_256&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x56&lt;/span&gt;
 
   &lt;span style=&#34;color:#a6e22e&#34;&gt;MURMUR3&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0x22&lt;/span&gt;
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;6cb42b2e29c28aeb143c3b9a0d9787f38ce2e5efea68ab01df6e121e4146ed8d 看上去是 64 位，那是因为用了十六进制的表示方式，每个字符表示4个bit，加在一起就是 256 bit，也就是 32 字节，转化为 16 进制就是 &lt;code&gt;0x20&lt;/code&gt;，故第二位就是 &lt;code&gt;20&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;multihash-基本使用&#34;&gt;multihash 基本使用&lt;/h2&gt;
&lt;p&gt;multihash 有多种实现版本，这里我们使用 go-multihash 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;go-multihash 的安装&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;go get github.com/multiformats/go-multihash/multihash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;基本使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 multihash -h 查看其所有参数选项，可以发现它默认使用的 HASH 算法是 sha2-256，编码格式为 base58。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;usage: multihash &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;options&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;FILE&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
Print or check multihash checksums.
With no FILE, or when FILE is -, read standard input.
 
Options:
  -a string
        one of: blake2b-128, blake2b-224, blake2b-256, blake2b-384, blake2b-512, blake2s-256, dbl-sha2-256, id, keccak-224, keccak-256, keccak-384, keccak-512, murmur3, sha1, sha2-256, sha2-512, sha3, sha3-224, sha3-256, sha3-384, sha3-512, shake-128, shake-256 &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;shorthand&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;default &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sha2-256&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
  -algorithm string
        one of: blake2b-128, blake2b-224, blake2b-256, blake2b-384, blake2b-512, blake2s-256, dbl-sha2-256, id, keccak-224, keccak-256, keccak-384, keccak-512, murmur3, sha1, sha2-256, sha2-512, sha3, sha3-224, sha3-256, sha3-384, sha3-512, shake-128, shake-256 &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;default &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sha2-256&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
  -c string
        check checksum matches &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;shorthand&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
  -check string
        check checksum matches
  -e string
        one of: raw, hex, base58, base64 &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;shorthand&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;default &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;base58&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
  -encoding string
        one of: raw, hex, base58, base64 &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;default &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;base58&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
  -h    display help message &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;shorthand&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
  -help
        display help message
  -l int
        checksums length in bits &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;truncate&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;. -1 is default &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;shorthand&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;default -1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
  -length int
        checksums length in bits &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;truncate&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;. -1 is default &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;default -1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
  -q    quiet output &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;no newline on checksum, no error text&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;shorthand&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
  -quiet
        quiet output &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;no newline on checksum, no error text&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面我们尝试使用 multihash 对一个文件进行校验计算。首先新建一个 enp.txt 文件，输入内容为 “正道成功，EPN”，再执行 multihash epn.txt 命令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo &amp;quot;正道成功，EPN&amp;quot; &amp;gt; epn.txt
$ multihash epn.txt
$ QmbftC2aCSGeFLWu995pBGpMvQGgWoMXBxZG2JxDYd9GLP
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;multihash-计算过程探究&#34;&gt;multihash 计算过程探究&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;首先对内容进行 sha2-256 HASH 计算。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ shasum -a &lt;span style=&#34;color:#ae81ff&#34;&gt;256&lt;/span&gt; epn.txt
$ c6153579704c93e8d7fbcfbb639b99213c0a6d8397facd0a58d2fc8f4d5dd2e0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;multihash 格式封装： 加上 sha2-256 的编码以及 HASH 长度得到的字符串为 1220c6153579704c93e8d7fbcfbb639b99213c0a6d8397facd0a58d2fc8f4d5dd2e0。&lt;/li&gt;
&lt;li&gt;base58 编码： base58 最早使用在 btc 钱包地址上，它相对于传统的 base64 而言，去除了某些不和谐，阅读不友好的字符，例如 +/-,O/0 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ pip install base58
$ python
  
&amp;gt;&amp;gt;&amp;gt; import base58
&amp;gt;&amp;gt;&amp;gt; base58.b58encode_int&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;int&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1220c6153579704c93e8d7fbcfbb639b99213c0a6d8397facd0a58d2fc8f4d5dd2e0&amp;#34;&lt;/span&gt;, 16&lt;span style=&#34;color:#f92672&#34;&gt;))&lt;/span&gt;
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;QmbftC2aCSGeFLWu995pBGpMvQGgWoMXBxZG2JxDYd9GLP&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，通过 python 编码得到的 base58 结果和直接使用 go-multihash 结果一致，都是 QmbftC2aCSGeFLWu995pBGpMvQGgWoMXBxZG2JxDYd9GLP。&lt;/p&gt;
&lt;h2 id=&#34;multihash-与-ipfs&#34;&gt;multihash 与 IPFS&lt;/h2&gt;
&lt;p&gt;经常使用 IPFS 的人可能会发现其内容 HASH 都是以 Qm 开头，这和我们刚使用 go-multihash 计算的一致，这是因为 IPFS 直接使用了multihash 的默认选项，即 sha2-256 + base58。&lt;/p&gt;
&lt;p&gt;我们尝试使用 ipfs 命令计算  epn.txt 的 HASH 值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ipfs add epn.txt
added QmarcwWsQp5ew7jnFtqYTLgkWEWaMPde8gme5ApZQXvZkU epn.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你会发现使用 ipfs 计算得出的 HASH 和直接使用 go-multihash 计算的不同，这是因为 ipfs 对内容进行 sha2-256 计算的时候，会对内容进行一定的加工（首尾添加特定字节），这点可以使用 ipfs object get 来查看。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ipfs object get QmarcwWsQp5ew7jnFtqYTLgkWEWaMPde8gme5ApZQXvZkU
&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Links&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Data&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\u0008\u0002\u0012\u0013正道成功，EPN\n\u0018\u0013&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以使用 multihash 对 ipfs 加工后的内容重新进行计算：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ipfs block get QmarcwWsQp5ew7jnFtqYTLgkWEWaMPde8gme5ApZQXvZkU &amp;gt; epn-ipfs.txt
$ multihash epn-ipfs.txt
QmarcwWsQp5ew7jnFtqYTLgkWEWaMPde8gme5ApZQXvZkU
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到此时计算出的 HASH 值与 IPFS 计算出的保持一致。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;我们通过实际例子对 multihash 的格式，计算过程有深刻认识，其次我们还可以发现 ipfs 与 multihash 之间的内在联系，总而言之 IPFS 内容 HASH 计算过程可以大致看成 内容封装 &amp;gt; hash2-256 计算 &amp;gt; multihash 格式封装 &amp;gt; base58 编码。&lt;/p&gt;
&lt;p&gt;参考链接: &lt;a href=&#34;https://zhuanlan.zhihu.com/p/43853989&#34;&gt;https://zhuanlan.zhihu.com/p/43853989&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IPFS peer 扩容方案</title>
      <link>/posts/ipfs-peer-kuo-rong-fang-an/</link>
      <pubDate>Wed, 10 Oct 2018 19:44:33 +0800</pubDate>
      
      <guid>/posts/ipfs-peer-kuo-rong-fang-an/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;我们都知道 IPFS 默认安装在 ~/.ipfs 目录，存储空间(StorageMax) 为 10GB， 这显然无法满足生产环境的需求，毕竟现在一个机械硬盘动则就是几个TB。那我们该如何对 IPFS 单一节点的容量进行扩充，做到同时使用多个硬盘？&lt;/p&gt;
&lt;h2 id=&#34;环境&#34;&gt;环境&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Linux 系统&lt;/li&gt;
&lt;li&gt;三个物理硬盘盘分别为 /dev/vda1(系统盘)，/dev/vdb1（100GB），/dev/vdc1(100GB)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;方案&#34;&gt;方案&lt;/h2&gt;
&lt;p&gt;步骤1:  使用 LVM 将两个物理硬盘 /dev/vdb1 和 /dev/vdc1 组成同一物理卷组，最后再再物理卷组中创建逻辑卷组 （LV），具体命令如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 创建物理卷（PV）&lt;/span&gt;
pvcreate /dev/sdb1
pvcreate /dev/sdc1
  
&lt;span style=&#34;color:#75715e&#34;&gt;# 查看已经创建好的物理卷&lt;/span&gt;
pvdisplay
  
&lt;span style=&#34;color:#75715e&#34;&gt;# 创建物理卷组&lt;/span&gt;
vgcreate IPFS /dev/sdb1 /dev/sdc1
  
&lt;span style=&#34;color:#75715e&#34;&gt;#创建逻辑卷（LV）&lt;/span&gt;
lvcreate -L 195G IPFS -n IPFS
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时，现在你的逻辑卷应该已经在 /dev/mapper/ 和 &lt;em&gt;/dev/YourVolumeGroupName&lt;/em&gt; 中了。&lt;/p&gt;
&lt;p&gt;步骤2:  挂载到目录 /IPFS ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;mkdir /IPFS
mkfs.ext4 /dev/mapper/VolGroup00-lvolhome
mount /dev/mapper/VolGroup00-lvolhome /IPFS
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;步骤3: 设置环境变量 IPFS_PATH, 指向挂在的目录：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;export IPFS_PATH&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;/IPFS
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;步骤4:  ipfs 初始化、配置、启动应用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ipfs init
vi /IPFS/config &lt;span style=&#34;color:#75715e&#34;&gt;# 修改 StorageMax 参数，设置大小为 190GB，具体按照自己的磁盘大小设置。&lt;/span&gt;
ipfs daemon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时你将看到 ipfs 运行在了 /IPFS 目录，并且所有数据 blocks 存储在了 /IPFS/blocks ， 整个 ipfs 可以用的数据空间为 190 GB。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;我们通过 LVM 将多个物理硬盘连成物理硬盘组，再将磁盘组划分为一个大容量的逻辑卷，并将该卷挂载到我们的 IPFS_PATH 目录，从而使 IPFS 节点可以同时使用多个硬盘的存储空间。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IPFS GC研究</title>
      <link>/posts/ipfs-cun-chu-kong-jian-gc/</link>
      <pubDate>Tue, 25 Sep 2018 16:26:01 +0800</pubDate>
      
      <guid>/posts/ipfs-cun-chu-kong-jian-gc/</guid>
      <description>&lt;p&gt;众所周知 IPFS 节点（peer）在初始化以后，默认使用的存储空间是 10GB（ipfs config show 可以查看），但随着 peer 节点加入网络的时间越来越久，存储空间使用率会逐步增加，直到达到上限，此时该节点将不再提供存储功能（但还能提供老数据的网络请求服务）。&lt;/p&gt;
&lt;h2 id=&#34;gc-猜想&#34;&gt;GC 猜想&lt;/h2&gt;
&lt;p&gt;对于这种情况，其实 IPFS 是提供了 GC 机制的，这个可以从 ipfs config 的  &lt;code&gt;StorageGCWatermark&lt;/code&gt; 参数得出。只是 GC 默认被关闭了，需要使用 &lt;code&gt;ipfs daemon --enable-gc&lt;/code&gt; 来启动，我们还可以使用 &lt;code&gt;ipfs repo gc&lt;/code&gt; 来手动 GC 。&lt;/p&gt;
&lt;p&gt;猜想： 存储空间主要使用在两个方面，主动添加的内容（pined content）和节点访问而 Cache 的内容，当执行 GC 的时候，只删除 Cache 部分的内容，而被 pin 的内容应该被保留。&lt;/p&gt;
&lt;h2 id=&#34;猜想验证&#34;&gt;猜想验证&lt;/h2&gt;
&lt;p&gt;实验环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IPFS 私网搭建，参考&lt;a href=&#34;https://zhuanlan.zhihu.com/p/35141862&#34;&gt;链接&lt;/a&gt; 。&lt;/li&gt;
&lt;li&gt;两台虚拟机。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此时两台虚拟机构建一个 IPFS 私网，它们分别为 ipfs01 和 ipfs02，数据只会在它们之间共享。&lt;/p&gt;
&lt;h3 id=&#34;实验过程&#34;&gt;实验过程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;step 1. 在 ipfs01 添加一张照片，然后执行 &lt;code&gt;ipfs pin | grep $HASH&lt;/code&gt; 查看是否已经 pined。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs_gc01.png&#34; alt=&#34;gc01&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Tips:  通过 ipfs add 命令的时候，内容会直接被 pined。&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;step 2. 在 ipfs02 中通过命令 &lt;code&gt;ipfs cat $HASH &amp;gt; cat.jpg&lt;/code&gt;  来下载该文件，然后执行 &lt;code&gt;ipfs pin | grep $HASH&lt;/code&gt; 查看是否 pined。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs_gc02.png&#34; alt=&#34;gc02&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过 ipfs cat 把 ipfs01 中的 cat.jpg 下载到了 ipfs02 ，我们可以通过浏览器查看其内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs_gc03.png&#34; alt=&#34;gc03&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Tips:  内容只是被缓存，并没有 pined。&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;step3 : 将 ipfs01 中的 $HASH unpin, 并在本地执行 &lt;code&gt;ipfs repo gc&lt;/code&gt; ，可以看到 该 $HASH 被清除：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs_gc04.png&#34; alt=&#34;gc04&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;step 4: 在 ipfs01 中重复执行 step 2 步骤：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs_gc05.png&#34; alt=&#34;gc05&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Tips:  可以看到 ipfs01 可以从 ipfs02 缓存节点中读取内容并保存。&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;step 5:  在两台机器中分别执行 &lt;code&gt;ipfs repo gc&lt;/code&gt; 后，再执行 &lt;code&gt;ipfs cat $HASH&lt;/code&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs_gc06.png&#34; alt=&#34;gc06&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Tips: 可以看到分别执行 gc 后，所有的缓存备份都被删除，故在全网中都无法搜索到内容，直到最后超时。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论：&lt;/h2&gt;
&lt;p&gt;通过实验，验证了我们的猜想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先 IPFS 存在 GC ，其次它只 GC  Cache 内容(即 unpin)。&lt;/li&gt;
&lt;li&gt;因为默认 GC 不开启，此时 cached 和 pined 内容等效。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>IPFS 三端可用性调研</title>
      <link>/posts/ipfs-zai-san-duan-ke-yong-xing-diao-yan/</link>
      <pubDate>Wed, 19 Sep 2018 16:03:24 +0800</pubDate>
      
      <guid>/posts/ipfs-zai-san-duan-ke-yong-xing-diao-yan/</guid>
      <description>&lt;h2 id=&#34;三端指什么&#34;&gt;三端指什么&lt;/h2&gt;
&lt;p&gt;三端指浏览器，Android, iOS ，当前绝大多数互联网应用都跑在这三个终端上，所以 IPFS 在它们上的运行成熟度直接决定了 IPFS 最终流行程度，我们有必要提前了解并做好准备。&lt;/p&gt;
&lt;h2 id=&#34;浏览器&#34;&gt;浏览器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;状态： 可行&lt;/li&gt;
&lt;li&gt;语言： JS&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ipfs/in-web-browsers&#34;&gt;https://github.com/ipfs/in-web-browsers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ipfs/js-ipfs&#34;&gt;https://github.com/ipfs/js-ipfs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;android&#34;&gt;Android&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;状态： 可行&lt;/li&gt;
&lt;li&gt;语言：kotlin&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ligi/ipfs-api-kotlin&#34;&gt;https://github.com/ligi/ipfs-api-kotlin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ligi/IPFSDroid&#34;&gt;https://github.com/ligi/IPFSDroid&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ios&#34;&gt;iOS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;状态： 可行&lt;/li&gt;
&lt;li&gt;语言： swift&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ipfs/swift-ipfs-api&#34;&gt;https://github.com/ipfs/swift-ipfs-api&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，社区很多人都在三端进行尝试，都希望 IPFS 能够在更多的平台上进行运行，尤其是移动端，这样可以大大扩充节点的数量。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IPFS 生态概览</title>
      <link>/posts/ipfs-sheng-tai-gai-lan/</link>
      <pubDate>Wed, 22 Aug 2018 15:27:35 +0800</pubDate>
      
      <guid>/posts/ipfs-sheng-tai-gai-lan/</guid>
      <description>&lt;p&gt;要想全面了解 IPFS 就不得不提 &lt;a href=&#34;https://protocol.ai/work/&#34;&gt;Protocal labs&lt;/a&gt;，目前它主要的项目包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ipfs.io/&#34;&gt;IPFS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://filecoin.io/&#34;&gt;Filecoin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://libp2p.io/&#34;&gt;libp2p&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ipld.io/&#34;&gt;IPLD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://multiformats.io&#34;&gt;Multiformats&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那为什么会有这些项目，这些项目产生的背景，以及最核心的功能又是什么？看完本篇概览，你就会找到答案。&lt;/p&gt;
&lt;h2 id=&#34;ipfs&#34;&gt;IPFS&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;IPFS is a new protocol to decentralize the web. IPFS enables the creation of completely decentralized and distributed applications, using content addressing and digital signatures。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;IPFS是一种去中心化网络的新协议。 IPFS支持使用内容寻址和数字签名创建完全去中心化的分布式应用程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到， IPFS 主要作为一种网络协议，使得通过它构建完全去中心的分布式应用程序（DApp）成为可能（当然还有其他的方式，例如 ETH），但是就像传统中心化的应用，DApp 对于永久可靠性存储的需求一直都在，并且成为 DApp 能够爆发的关键一环，当然也直接决定了 IPFS 协议最终的成功。&lt;/p&gt;
&lt;p&gt;虽然已经有不少去中心化存储网络(DSN)解决方案，但是介于方案的成熟度，性能，以及与 IPFS 整合能力各方面的考量，由 Protocal labs 自己来实现 Filecoin 的方案才是最靠谱的。这样也会大量利用到 IPFS 已有的技术，例如底层网络连接和数据交换（libp2p）以及去中心化数据的通用定义（IPLD）。&lt;/p&gt;
&lt;p&gt;在 IPFS 技术栈中不得不提 ipfs-cluster, 它是 IPFS 的 Pinset 编排程序，通过它可以构建更大的容量的 IPFS PinSet 集群，利用它可以构建一个去中心化的永久存储系统。个人认为它和 Filecoin 关注的重点不同，因为 Filecoin 是在公链中构建带有存储激励的存储网络，而 ipfs-cluster 相当于通过自己可控的节点构建超大的 IPFS PinSet 集群，而且目前 ipfs-cluster 的成熟度高于 Filecoin。&lt;/p&gt;
&lt;h2 id=&#34;filecoin&#34;&gt;Filecoin&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Filecoin is a cryptocurrency powered storage network. Miners earn Filecoin by providing open hard-drive space to the network, while users spend Filecoin to store their files encrypted in the decentralized network.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Filecoin 是一种加密货币驱动的存储网络。 矿工通过向网络提供开放的硬盘空间来获得Filecoin，而用户使用Filecoin来存储他们在分散网络中加密的文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;DApp 是需要大量永久性去中心化存储的，这一点 IPFS 无法满足，所以 Filecoin 孕育而生，而且通过 FileCoin + IPFS 可以很好的解决整个 DApp 的内容存储和分发问题。&lt;/p&gt;
&lt;h2 id=&#34;libp2p&#34;&gt;libp2p&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;libp2p is a modular networking stack. libp2p brings together a variety of transports and peer-to-peer protocols, making it easy for developers to build large, robust p2p networks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;libp2p 是一个模块化的网络技术栈。 libp2p汇集了各种传输和点对点协议，使开发人员可以轻松构建大型，强大的 p2p 网络。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前去中心化的网络都是基于 p2p 来构建的，例如 BTC, ETH 和 IPFS, 因为 IPFS 包含了一个强大的 p2p 网络，那么将它抽离出来,成为一个单独的项目，能够被其它开源项目所复用是非常有价值的。&lt;/p&gt;
&lt;h2 id=&#34;ipld&#34;&gt;IPLD&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;IPLD is the data model for the Decentralized Web. It connects all data through cryptographic hashes, and makes it easy to traverse and link to.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;IPLD是去中心化 Web 的数据模型。 它通过加密哈希连接所有数据，并使其易于遍历和链接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;IPFS 属于去中心化的 Web 协议，那么底层就依赖 IPLD，这样的数据结构能够在各种去中心的网络中实现数据共享和互访，例如（IPFS 和 ETH，BTC 等）。&lt;/p&gt;
&lt;h2 id=&#34;multiformats&#34;&gt;Multiformats&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;The Multiformats Project is a collection of protocols to future-proof systems, today. Self-describing formats make your systems interoperable and upgradable.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Multiformats 项目是当今面向未来系统的协议集合。 自描述的格式使你的系统可互操作和可升级。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Multiformats 主要强调其自描述性，故名思议可以通过格式就能知道其中含义，那么作为一组协议集合，它目前包含了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;multihash：自描述的 hash，主要用于 IPFS 中对于内容加密 hash 的描述。&lt;/li&gt;
&lt;li&gt;multiaddr：自描述的网络地址，主要用于 libp2p 的网络地址描述。&lt;/li&gt;
&lt;li&gt;multibase： 自我识别的基础编码。&lt;/li&gt;
&lt;li&gt;multicodec： 自描述序列化。&lt;/li&gt;
&lt;li&gt;multistream： 字描述的流式网络协议。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;IPFS 的目标是要在去中心化网络中主流（甚至唯一）的网络协议（类似 Web 中的 HTTP 的地位），但只有 IPFS协议显然是不够的，去中心化应用（网络）的普及，需要整个生态的共同发展，所以才有了后来的去中心化的数据模型（IPLD），去中心化的字描述数据格式（Multiformats），去中心化的永久性存储（FileCoin) 以及快速构建大型 p2p 应用的 libp2p 。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IPFS 二维码添加的问题</title>
      <link>/posts/ipfs-er-wei-ma-tian-jia-de-wen-ti/</link>
      <pubDate>Thu, 09 Aug 2018 21:01:37 +0800</pubDate>
      
      <guid>/posts/ipfs-er-wei-ma-tian-jia-de-wen-ti/</guid>
      <description>&lt;p&gt;前段时间在知乎上看到「飞向未来」大大早期文章 &lt;a href=&#34;https://zhuanlan.zhihu.com/p/32651288&#34;&gt;什么是IPFS?(三)&lt;/a&gt; 中有这样一段描述：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs/ipfs03.png&#34; alt=&#34;ipfs03.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是真的是这样吗？难道我们真的没有办法在一个网站中插入对应二维码？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;结论当然是可以，因为我们有 IPNS。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面我将介绍具体的实现步骤：&lt;/p&gt;
&lt;h3 id=&#34;step-1--占坑&#34;&gt;Step 1:  占坑&lt;/h3&gt;
&lt;p&gt;创建一个目录，添加到 IPFS 网络，先做好 IPNS 映射，这个过程就相当于在逻辑上先定义一个网站。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir demo
$ ipfs add -r demo

added QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn demo
 0 B / 68 B [---------------------------------------------------------------------------]   0.00%

$ ipfs name public QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn
Published to QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe: /ipfs/QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时我们已经可以通过 ipns/QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe 来访问网站了。&lt;/p&gt;
&lt;h3 id=&#34;step-2-添加网页&#34;&gt;Step 2: 添加网页&lt;/h3&gt;
&lt;p&gt;在 demo 目录下创建 &lt;code&gt;a.html&lt;/code&gt; 文件，并且在 &lt;code&gt;a.html&lt;/code&gt; 中添加如下内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;charset&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;UTF-8&amp;#34;&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;qrcode demo&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;style&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;text-align:center;&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;h1&lt;/span&gt;&amp;gt;this is a ipfs page with qrcode&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;h1&lt;/span&gt;&amp;gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;br&lt;/span&gt;/&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;img&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;a.png&amp;#34;&lt;/span&gt; /&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;step-3添加二维码&#34;&gt;Step 3：添加二维码&lt;/h3&gt;
&lt;p&gt;随便找一个二维码生成器生成 &lt;code&gt;a.html&lt;/code&gt; 对应 IPNS 二维码，并存放为 &lt;code&gt;demo/a.png&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs/ipns01.png&#34; alt=&#34;ipns01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;此时 &lt;code&gt;demo&lt;/code&gt; 目录结构是这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ tree demo/

demo/
├── a.png
└── a.html

&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; directories, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;step-4-更新并发布网站&#34;&gt;Step 4: 更新并发布网站&lt;/h3&gt;
&lt;p&gt;依次执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs add -r demo

added QmNU5XXUpDnAXv88nDTcafKFY3h5LhKLJnkf2XBBGtc8wW demo/a.html
added QmcZhDddySHAdaJa9zKBRkY9SBrDJTWsq5Fn5chCDPXz3j demo/a.png
added QmSUCYnZ6SrGaAs8gaAAmf5tgjYAGMKjwMX3r4k7FxvCx1 demo
 2.23 KiB / 2.36 KiB [==============================================================&amp;gt;---]  94.37%

$ ipfs name publish QmSUCYnZ6SrGaAs8gaAAmf5tgjYAGMKjwMX3r4k7FxvCx1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后打开浏览器访问地址 &lt;a href=&#34;https://ipfs.io/ipns/QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe/a.html&#34;&gt;https://ipfs.io/ipns/QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe/a.html&lt;/a&gt; 将看到刚发布的 &lt;code&gt;a.html&lt;/code&gt; 页面，并包含对应二维码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs/ipns02.png&#34; alt=&#34;ipns02.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;到此为止，这个先有鸡还是先有蛋的问题已被我们解决，通过此例可以让我们加深对 IPNS 的认识。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 IPFS 搭建个人博客</title>
      <link>/posts/shi-yong-ipfs-da-jian-ge-ren-bo-ke/</link>
      <pubDate>Wed, 08 Aug 2018 20:35:00 +0800</pubDate>
      
      <guid>/posts/shi-yong-ipfs-da-jian-ge-ren-bo-ke/</guid>
      <description>&lt;p&gt;本文主要讲解如何使用 IPFS 搭建个人博客，从而实现个人博客在网络中的“永生”。&lt;/p&gt;
&lt;p&gt;主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IPFS 简介&lt;/li&gt;
&lt;li&gt;IPFS 安装和基本使用&lt;/li&gt;
&lt;li&gt;IPFS 的内容发布&lt;/li&gt;
&lt;li&gt;IPNS 的内容发布&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ipfs-简介&#34;&gt;IPFS 简介&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://ipfs.io/&#34;&gt;IPFS&lt;/a&gt; 是 InterPlanetary File System 的简称，中文名叫星际文件系统，是一个旨在创建持久且分布式存储和共享文件的网络传输协议。&lt;/p&gt;
&lt;p&gt;它是一种内容可寻址的对等超媒体分发协议，在 IPFS 网络中的所有节点将构成一个分布式文件系统，使用点对点的超媒体协议，从而让网络更快、更安全、更开放。&lt;/p&gt;
&lt;h3 id=&#34;ipfs-安装&#34;&gt;IPFS 安装&lt;/h3&gt;
&lt;p&gt;访问页面 &lt;a href=&#34;https://github.com/ipfs/go-ipfs/releases&#34;&gt;https://github.com/ipfs/go-ipfs/releases&lt;/a&gt; 下载对应版本，解压，运行安装文件即可。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ wget https://github.com/ipfs/go-ipfs/releases/download/v0.4.17/go-ipfs_v0.4.17_darwin-amd64.tar.gz

$ tar xvf go-ipfs_v0.4.17_darwin-amd64.tar.gz
$ cd go-ipfs &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; ./install.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;安装成功后，执行 &lt;code&gt;ipfs version&lt;/code&gt; 你将看到类似内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ipfs version

ipfs version 0.4.17
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令 &lt;code&gt;ipfs -h&lt;/code&gt; 来查看更多命令&lt;/li&gt;
&lt;li&gt;命令 &lt;code&gt;cat ~/.ipfs/config&lt;/code&gt; 可以查看所有默认配置项&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;新建-ipfs-节点&#34;&gt;新建 IPFS 节点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;运行 &lt;code&gt;ipfs init&lt;/code&gt; 初始化节点&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ipfs init
initializing IPFS node at /Users/sjy/.ipfs
generating 2048-bit RSA keypair...done
peer identity: QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe
to get started, enter:

	ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;初始化成功后，可以使用 &lt;code&gt;ipfs cat&lt;/code&gt; 命令来查看 IPFS 网络中的文件，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme
Hello and Welcome to IPFS!

██╗██████╗ ███████╗███████╗
██║██╔══██╗██╔════╝██╔════╝
██║██████╔╝█████╗  ███████╗
██║██╔═══╝ ██╔══╝  ╚════██║
██║██║     ██║     ███████║
╚═╝╚═╝     ╚═╝     ╚══════╝

If you&#39;re seeing this, you have successfully installed
IPFS and are now interfacing with the ipfs merkledag!

 -------------------------------------------------------
| Warning:                                              |
|   This is alpha software. Use at your own discretion! |
....
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;ipfs id&lt;/code&gt; 查看节点基本信息&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs id

{
	&amp;quot;ID&amp;quot;: &amp;quot;QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe&amp;quot;,
	&amp;quot;PublicKey&amp;quot;: &amp;quot;...&amp;quot;,
	&amp;quot;Addresses&amp;quot;: [
		&amp;quot;/ip4/127.0.0.1/tcp/4001/ipfs/QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe&amp;quot;,
		&amp;quot;/ip4/100.100.58.79/tcp/4001/ipfs/QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe&amp;quot;,
		&amp;quot;/ip4/100.100.6.124/tcp/4001/ipfs/QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe&amp;quot;,
		&amp;quot;/ip6/::1/tcp/4001/ipfs/QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe&amp;quot;,
		&amp;quot;/ip4/103.20.32.163/tcp/4001/ipfs/QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe&amp;quot;
	],
	&amp;quot;AgentVersion&amp;quot;: &amp;quot;go-ipfs/0.4.17/&amp;quot;,
	&amp;quot;ProtocolVersion&amp;quot;: &amp;quot;ipfs/0.1.0&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;运行 &lt;code&gt;ipfs daemon&lt;/code&gt; 连接网络&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs daemon
Initializing daemon...
Swarm listening on /ip4/100.100.58.79/tcp/4001
Swarm listening on /ip4/100.100.6.124/tcp/4001
Swarm listening on /ip4/127.0.0.1/tcp/4001
Swarm listening on /ip6/::1/tcp/4001
Swarm listening on /p2p-circuit/ipfs/QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe
Swarm announcing /ip4/100.100.58.79/tcp/4001
Swarm announcing /ip4/100.100.6.124/tcp/4001
Swarm announcing /ip4/127.0.0.1/tcp/4001
Swarm announcing /ip6/::1/tcp/4001
Error: serveHTTPApi: manet.Listen(/ip4/127.0.0.1/tcp/5001) failed: listen tcp4 127.0.0.1:5001: bind: address already in use
Received interrupt signal, shutting down...
(Hit ctrl-c again to force-shutdown the daemon.)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有时你会遇到端口冲突的问题，可以使用 &lt;code&gt;vi ~/.ipfs/config&lt;/code&gt; 修改默认配置来解决，相关内容为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// from
&amp;quot;API&amp;quot;: &amp;quot;/ip4/127.0.0.1/tcp/5001&amp;quot;,
&amp;quot;Gateway&amp;quot;: &amp;quot;/ip4/127.0.0.1/tcp/8080&amp;quot;

// to 
&amp;quot;API&amp;quot;: &amp;quot;/ip4/127.0.0.1/tcp/9091&amp;quot;,
&amp;quot;Gateway&amp;quot;: &amp;quot;/ip4/127.0.0.1/tcp/9090&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;保存修改后，再次运行 &lt;code&gt;ipfs daemon&lt;/code&gt;，可以看到如下输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs daemon

Initializing daemon...
Swarm listening on /ip4/100.100.58.79/tcp/4001
Swarm listening on /ip4/100.100.6.124/tcp/4001
Swarm listening on /ip4/127.0.0.1/tcp/4001
Swarm listening on /ip6/::1/tcp/4001
Swarm listening on /p2p-circuit/ipfs/QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe
Swarm announcing /ip4/100.100.58.79/tcp/4001
Swarm announcing /ip4/100.100.6.124/tcp/4001
Swarm announcing /ip4/127.0.0.1/tcp/4001
Swarm announcing /ip6/::1/tcp/4001
API server listening on /ip4/127.0.0.1/tcp/9091
Gateway (readonly) server listening on /ip4/127.0.0.1/tcp/9090
Daemon is ready
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后打开浏览器访问 &lt;code&gt;http://localhost:9091/webui&lt;/code&gt; 可以看到如下内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs/webui.png&#34; alt=&#34;webui&#34;&gt;&lt;/p&gt;
&lt;p&gt;这说明我们已经成功加入 IPFS 网络。&lt;/p&gt;
&lt;h3 id=&#34;添加个人博客&#34;&gt;添加个人博客&lt;/h3&gt;
&lt;p&gt;长期以来我都是使用 Jekyll 来写博客，这里就用它来示范，当然大家也可以使用其它静态网站生成器，例如（hugo）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;jekyll build&lt;/code&gt; 生成最新博客内容&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;ipfs add -r _site&lt;/code&gt; 添加博客站&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs add -r _site

added QmRum1Gg9DjYm8xosqaEd2YMdYZaVjUqifNC7xEQcxgCyn _site/404.html
added QmXMGUT9SMFa9nx4FcN5AQmPV4GBChAzUNzN2KUqJSQb5Q _site/CNAME
added Qme8R4NpB93Tcy55vhZhgReCkaehfhB6NGcMyHWFhNjGvJ _site/Gemfile
added QmPWR1QN9wVUtBGUm6PhwpwhuRHQXttrHufm6y8AYWzP4p _site/Gemfile.lock
added QmXWVVA17LnCZMqsTx75hZDeFhoJRJeKWEeU3dufQUkhmo _site/LICENSE
added Qmdvx2PCV3kQD8PvCFtsCi68mapc1fpkgS8FrQod42HxWh _site/README.md
added QmRHRq49njYPheLBMV8RTCnuDWcapkwRBhVNWXQPvThUyh _site/about.html
added QmPmmp8C2BaLvhFb2M43xdTgvUAtV5xREG2AAMiNpfgF2A _site/feed.xml
added QmPE53kbhLfSPUdAkieGR4NB6aA79ojkcQVB5WgksgiCoi _site/images/404.png
.....
added QmZw6t1FiWMMKgB5o4KohJ7wqHDvHRRBRvc8FmRwshejpR _site
58.51 MiB / 116.73 MiB [===========================================&amp;gt;------------------------------------------]  50.13% 00m03s
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到整个网站以 &lt;code&gt;_site&lt;/code&gt; 为根目录，当前的版本为 &lt;code&gt;QmZw6t1FiWMMKgB5o4KohJ7wqHDvHRRBRvc8FmRwshejpR&lt;/code&gt;，然后我们就可以通过链接 &lt;code&gt;https://ipfs.io/ipfs/QmZw6t1FiWMMKgB5o4KohJ7wqHDvHRRBRvc8FmRwshejpR&lt;/code&gt; 在浏览器中查看到最新的博客内容了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs/ipfs01.jpg&#34; alt=&#34;ipfs01.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;发布到-ipns&#34;&gt;发布到 IPNS&lt;/h3&gt;
&lt;p&gt;当博客更新后，会生成新的 hash，要访问最新版本的内容就需要新生成的 hash，那如何使用一个固定的链接来访问最新版本的内容呢？&lt;/p&gt;
&lt;p&gt;这就需要使用到 IPNS，IPNS 是 IPFS 的命名系统，它允许用户使用一个私有密钥来对哈希附加一个引用，使用一个公共密钥哈希（简称 pubkeyhash）表示你的网站的最新版本。&lt;/p&gt;
&lt;p&gt;具体操作如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs name publish QmZw6t1FiWMMKgB5o4KohJ7wqHDvHRRBRvc8FmRwshejpR

Published to QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe: /ipfs/QmZw6t1FiWMMKgB5o4KohJ7wqHDvHRRBRvc8FmRwshejpR
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行完命令后，我们就完成了博客和一个固定的 link 的绑定，我们可以使用 &lt;code&gt;ipfs name resolve xxx&lt;/code&gt; 来查看固定 link 绑定的版本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ipfs name resolve QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe

/ipfs/QmZw6t1FiWMMKgB5o4KohJ7wqHDvHRRBRvc8FmRwshejpR
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后我们通过 ipns + 生成的固定 hash （QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe）来访问博客了，例如:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/ipfs/ipfs02.jpg&#34; alt=&#34;ipfs02.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;当我们博客有更新的时候，只需要再次执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ jekyll build
$ ipfs add -r _site
$ ipfs name publish &amp;lt;最新 hash&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并使用固定的 IPNS hash  &lt;code&gt;QmR94EL86DjAuRQDdYeShG84ahqH4M39VFD8PbToiVobRe&lt;/code&gt; 来访问即可。&lt;/p&gt;
&lt;p&gt;至此，我们基本完成了个人博客的 IPFS 发布，最后就剩的个人域名的绑定了，这个留到后面的文章来讲解。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;我们通过 IPFS 的安装、创建网络节点、添加网站、发布固定网站，学习了 IPFS 基础概念、基本操作、基于内容寻址的访问方式、以及 IPNS 和 IPFS 的对应关系。&lt;/p&gt;
&lt;p&gt;可以看到使用 IPFS 搭建个人博客，乃至 WIKI 等内容网站是非常高效的，大家不妨尝试一下。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>